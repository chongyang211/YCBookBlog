# 1.2浮点型数据深入分析
#### 目录介绍
- 01.浮点型数据对比分析
  - 1.1 首先看个案例1
  - 1.2 对结果分析
  - 1.3 默认double思考
- 02.浮点型数据精度丢失
  - 2.1 看一个案例2
  - 2.2 案例分析一下
  - 2.4 什么精度丢失
  - 2.5 精度为何会丢失
  - 2.6 浮点数如何判断
- 03.计算机设计浮点由来
  - 3.1 用比特表示数
  - 3.2 定点数的表示
  - 3.3 浮点数的表示
  - 3.4 浮点型原理设计
  - 3.5 浮点型编码格式
  - 3.6 符号位设计思想
  - 3.7 阶码位设计思想
  - 3.8 尾数位设计思想
- 04.浮点数二进制转化
  - 4.1 浮点数二进制表示
  - 4.2 浮点数据转化十进制
  - 4.3 浮点数规格化表示
  - 4.4 浮点数加法和精度丢失
- 05.回归到开始问题
  - 5.1 浮点数解析代码
  - 5.2 案例1结果分析
  - 5.3 案例2结果分析
- 06.BigDecimal设计
  - 6.1 BigDecimal介绍
  - 6.2 BigDecimal设计思想
  - 6.3 BigDecimal原理


## 01.浮点型数据对比分析

### 1.1 首先看个案例1

先看一个案例，思考一下是否妥当

在此类问题中，编码时需要注意float基本数据类型需要添加后缀f，以及它的包装类Float的后缀F，不写后缀会默认为double类型。

```java
float a = 2.0000001F;
float b = 2.0000001F;
System.out.println(a == b);                 // 输出true
System.out.println(0.1f + 0.2f == 0.3f);    // 输出true
System.out.println(0.1 + 0.2 == 0.3);       // 输出false
System.out.println(0.3f + 0.6f == 0.9f);    // 输出false
System.out.println(0.3 + 0.6 == 0.9);       // 输出false
System.out.println(0.6 + 0.6 == 1.2);       // 输出true
System.out.println(0.2 + 0.2 == 0.4);       // 输出true
```

### 1.2 对结果分析

开始看到这个结果是不是直接懵了，先且不说不写后缀默认double的问题

```java
System.out.println(0.1f + 0.2f == 0.3f); // 输出true
System.out.println(0.3f + 0.6f == 0.9f); // 输出false
```

一个true一个false就直接懵逼了。那为什么会出现这样的情况，思考一下？要想搞清楚，我们就必须搞清楚计算机是如何存储浮点型数据的原理。

### 1.3 默认double思考

默认double数据对比思考

```java
System.out.println(0.1 + 0.2 == 0.3); // 输出false
System.out.println(0.3 + 0.6 == 0.9); // 输出false
System.out.println(0.6 + 0.6 == 1.2); // 输出true
System.out.println(0.2 + 0.2 == 0.4); // 输出true
```

通过这个案例可知，默认double类型，为何第一个和第二个案例返回结果是false，为何第三个第四个返回结果是true。

## 02.浮点型数据精度丢失

### 2.1 看一个案例2

看一个代码案例，如下所示

```java
float f = 1.4f;
double d = 1.4d;
float f1 = 1.5f;
double d1 = 1.5d;

System.out.println(f);              //1.4
System.out.println((double)f);      //1.399999976158142
System.out.println(d);              //1.4
System.out.println(f - d);          //-2.3841857821338408E-8
System.out.println(f == d);         //false

System.out.println("--------");
System.out.println(f1);             //1.5
System.out.println((double) f1);    //1.5
System.out.println(d1);             //1.5
System.out.println(f1 - d1);        //0.0
System.out.println(f1 == d1);       //true
```

### 2.2 案例分析一下

思考一下为何1.4f转化为double数据后，结果比原值要小。

System.out.println((double)f); //1.399999976158142

思考一下为何1.5f转化为double数据后，结果和原值一样。

System.out.println((double) f1); //1.5

### 2.4 什么精度丢失

十进制小数如何转化为二进制数？算法是乘以2直到没有了小数为止。举个例子，0.3表示成二进制数。在进行数值计算或转换时，由于数据类型的限制或精度问题导致的精度损失。

```java
0.3*2=0.6   取整数部分  0

0.6*2=1.2   取整数部分  1

0.2(1.2的小数部分)*2=0.4   取整数部分 0

0.4*2=0.8   取整数部分  0

0.8*2=1.6    取整数部分 1

0.6*2=1.2   取整数部分  1

.........     0.3二进制表示为(从上往下):0100110011......
```

上面的计算过程循环了，也就是说2永远不可能消灭小数部分，这样算法将无限下去。

很显然，小数的二进制表示有时是不可能精确的。而0.5能用二进制数精确表示0.52=1.0时能取整数部分。

其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了"减不尽"的精度丢失问题。

### 2.5 精度为何会丢失

精度丢失主要有两个原因：

1. 有限的表示范围：浮点数的表示范围是有限的，无法准确表示所有的实数。当一个实数超出浮点数的表示范围时，它会被近似表示为最接近的可表示值。这种近似导致了精度的丢失。

2. 二进制表示：浮点数在计算机中以二进制形式表示。某些实数在十进制中是无限循环的，但在二进制中无法精确表示。这会导致一些实数在转换为浮点数时产生舍入误差，从而导致精度丢失。

为何精度丢失

在计算机中，一切皆为整数在算术类型上，又分为整数和浮点数，浮点数是由 符号位、有效数字、指数位这些整数共同构成的。

但是计算机又不是使用人类的10进制，而是使用的2进制进行（指数）存储，所以理所当然的会有精度丢失。

十进制。10进制中的1/3这种除法我们想表示的时候只能用0.33333....来表示，那么当我们显示的位数是固定的时候就存在精度问题，1/3！=0.33，也不等于0.333333333。假设小数点之后我们只能写8位或者16位那么久丢失了精度。

二进制。所以在二进制中精度丢失也是一个道理。毕竟这种无限循环的事情，计算器不可能开辟一个无限大的空间去给你存储吧！

### 2.6 浮点数如何判断

浮点数判断需要注意，float和double的精度范围，超过范围的数字会被忽略

(1) 浮点数大小判断：如果没有等号关系在里面，也就必然一大一小，那么直接用 > 或者 <

(2) 浮点数相等判断：因为浮点数在内存中存放，可能无法精确的储存，所以同一个值，可能有不同的内存数据

正确做法：应该使用两个浮点数之间的差异的绝对值小于某个可以接受的值来判断判断它们是否相等

------------------------------------------------------------------------------

### 01.浮点数据对比
#### 1.1 先看一个案例
- 先看一个案例，思考一下是否妥当
    - 下面这个案例。用 == 从语法上说没错，但是本来应该相等的两个浮点数由于计算机内部表示的原因可能略有微小的误差，这时用==就会认为它们不等。
    ``` java
    float a = 2.0000001f;
    float b = 2.0000001f;
    if(a==b) {
       //
    }
    ```
- 首先说一下测试结果
    - 待完善





#### 1.2 浮点数如何判断
- 浮点数判断需要注意，float和double的精度范围，超过范围的数字会被忽略
    - (1) 浮点数大小判断：如果没有等号关系在里面，也就必然一大一小，那么直接用  > 或者 <
    - (2) 浮点数相等判断：因为浮点数在内存中存放，可能无法精确的储存，所以同一个值，可能有不同的内存数据
- 正确做法
    - 应该使用两个浮点数之间的差异的绝对值小于某个可以接受的值来判断判断它们是否相等
    ``` java
    private static final float EQUAL_FLOAT = 0.0000001f;
    if (Math.abs(a-b)> EQUAL_FLOAT && Math.abs(b-a)> EQUAL_FLOAT){
        
    }
    ```


### 02.什么是精度丢失
#### 2.1 看一个面试题
- 题目
    ``` java
    float f = 1.4f;double d = 1.4d; 与 float f = 1.5f;double d = 1.5d; 是否为true
    ```
- 测试代码
    ``` java
    float f = 1.4f;
    double d = 1.4d;
    float f1 = 1.5f;
    double d1 = 1.5d;
    
    while (true) {
        System.out.println(f);
        System.out.println((double)f);
        System.out.println(d);
        System.out.println(f - d);
        System.out.println(f == d);
    
        System.out.println("--------");
        System.out.println(f1);
        System.out.println((double) f1);
        System.out.println(d1);
        System.out.println(f1 - d1);
        System.out.println(f1 == d1);
    }
    
    1.4
    1.399999976158142
    1.4
    -2.3841857821338408E-8
    false
    --------
    1.5
    1.5
    1.5
    0.0
    true
    ```
- 十进制小数如何转化为二进制数？算法是乘以2直到没有了小数为止。举个例子，0.3表示成二进制数
    ``` java
    0.3*2=0.6   取整数部分  0
    
    0.6*2=1.2   取整数部分  1
    
    0.2(1.2的小数部分)*2=0.4   取整数部分 0
    
    0.4*2=0.8   取整数部分  0
    
    0.8*2=1.6    取整数部分 1
    
    0.6*2=1.2   取整数部分  1
    
    .........     0.3二进制表示为(从上往下):0100110011...... 
    ```
- 上面的计算过程循环了，也就是说2永远不可能消灭小数部分，这样算法将无限下去。
    - 很显然，小数的二进制表示有时是不可能精确的。而0.5能用二进制数精确表示0.52=1.0时能取整数部分。
    - 其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了"减不尽"的精度丢失问题。


#### 2.2 看精度丢失案例
- 先看一个例子
    - 精度为什么会丢失，计算机能存那么多数字，一个0.3+0.6怎么就丢精度了呢？
    ``` java
    public static void main(String[] args){
        System.out.println(0.3f + 0.6f);
        System.out.println(0.3 + 0.6);
        System.out.println(0.9);
    }
    输出:
    
    0.90000004
    0.8999999999999999
    0.9
    ```



#### 2.3 精度为何丢失
- 精度丢失主要有两个原因：
    - 有限的表示范围：浮点数的表示范围是有限的，无法准确表示所有的实数。当一个实数超出浮点数的表示范围时，它会被近似表示为最接近的可表示值。这种近似导致了精度的丢失。
    - 二进制表示：浮点数在计算机中以二进制形式表示。某些实数在十进制中是无限循环的，但在二进制中无法精确表示。这会导致一些实数在转换为浮点数时产生舍入误差，从而导致精度丢失。
- 为何精度丢失
    - 在计算机中，一切皆为整数在算术类型上，又分为整数和浮点数，浮点数是由 符号位、有效数字、指数位这些整数共同构成的。
    - 但是计算机又不是使用人类的10进制，而是使用的2进制进行（指数）存储，所以理所当然的会有精度丢失。
    - 十进制。10进制中的1/3这种除法我们想表示的时候只能用0.33333....来表示，那么当我们显示的位数是固定的时候就存在精度问题，1/3！=0.33，也不等于0.333333333。假设小数点之后我们只能写8位或者16位那么久丢失了精度。
    - 二进制。所以在二进制中精度丢失也是一个道理。毕竟这种无限循环的事情，计算器不可能开辟一个无限大的空间去给你存储吧！




### 03.二进制表达数据
#### 3.1 二进制表示方式
- 二进制是一种计算机中常用的数值表示方式，它使用两个数字0和1来表示数据。
    - 在计算机中，所有的数据都可以用二进制来表示，包括整数、浮点数、字符、图像、音频等。
    - 二进制位是计算机中最小的存储单位，通常以8个二进制位为一组，称为字节（byte）。
- 以下是一些常见数据类型的二进制表示方式：
    - 整数：整数可以使用二进制补码表示。正整数的二进制表示与其在十进制中的表示相同，负整数的二进制表示是其绝对值的二进制补码。
    - 浮点数：浮点数使用IEEE 754标准来表示。它将浮点数分为符号位、指数位和尾数位，使用二进制表示。
    - 字符：字符可以使用ASCII码或Unicode编码来表示。每个字符都有对应的二进制编码，可以使用二进制位来表示字符。
    - 图像和音频：图像和音频数据可以使用二进制位来表示像素值或采样值。每个像素或采样点都可以



#### 3.2 二进制表达整数
- 在二进制中，整数可以使用二进制补码表示。
    - 二进制补码是一种表示有符号整数的方法，它使用固定位数的二进制数来表示整数。
    - 在二进制补码表示中，最高位（最左边的位）用于表示符号位，0表示正数，1表示负数。其余位表示整数的数值部分。
- 二进制补码表示整数的一般规则：
    - 正整数：正整数的二进制表示与其在十进制中的表示相同。例如，十进制数5的二进制表示为0000 0000 0000 0101。
    - 负整数：负整数的二进制表示是其绝对值的二进制补码。二进制补码的计算方法是，将正整数的二进制表示按位取反（0变为1，1变为0），然后加1。例如，十进制数-5的二进制表示为1111 1111 1111 1011。
- 需要注意的问题如下所示
    - 二进制补码表示中，整数的位数是固定的。例如，使用8位二进制补码表示整数时，可以表示的范围是-128到127（包括0）。如果超出了这个范围，就会发生溢出。
    - 例如，使用8位二进制补码表示整数时，十进制数-128的二进制表示为10000000，十进制数127的二进制表示为01111111。




#### 3.3 二进制表达浮点数
- 浮点数在计算机中的存储方式其实是以补码的形式。在计算机中，数字都是用补码来表示与存储的。
    - 正数的补码是其二进制表示的，负数的补码是其正数的二进制取反再加一。然后就是为什么0.3+0.6会导致精度丢失了。
    - 0.3转化为二进制为0.0100110011001100）结果是保留16位的，然后导致了精度的丢失；（0.6转化为0.1001100110011001）结果是保留16位的，也导致了精度的丢失；相加起来就是0.1110011001100101再转化为十进制为0.8999786376953125和上面结果不同，但差不多应该是计算精度的不同吧。


#### 3.4 二进制表达字符
- 在计算机中，字符可以使用不同的编码方案来进行二进制表示。最常见的编码方案是ASCII码和Unicode编码。
    - ASCII码：ASCII是一种最早的字符编码方案，使用7位二进制数（0-127）来表示128个字符，包括英文字母、数字、标点符号和一些控制字符。例如，字符'A'的ASCII码表示为二进制数01000001。
    - Unicode编码：Unicode是一种更为广泛的字符编码方案。它使用不同的编码方式，如UTF-8、UTF-16等。UTF-8是一种变长编码方式，使用8位二进制数（0-255）来表示字符。UTF-16是一种定长编码方式，使用16位二进制数（0-65535）来表示字符。
- 在二进制中，字符的表示方式取决于所使用的编码方案。
    - 例如，字符'A'的ASCII码表示为二进制数01000001，而在UTF-8编码中，字符'A'的表示为01000001。
    - 不同的编码方案可能使用不同的位数来表示字符，因此在进行字符编码和解码时，需要使用相应的编码方案来正确地转换二进制数据。



#### 3.5 二进制表达图像




#### 3.6 二进制传输注意点
- 在进行二进制传输时，有一些注意点需要考虑，以确保数据的正确性和可靠性：
    - 数据长度：在传输二进制数据时，需要确保发送方和接收方对数据长度的解释是一致的。可以在数据中包含长度信息，或者使用固定长度的数据块进行传输。
    - 数据校验：为了确保数据的完整性，可以使用校验和或哈希算法对二进制数据进行校验。发送方在发送数据之前计算校验和，并将其附加到数据中。接收方在接收数据后重新计算校验和，并与接收到的校验和进行比较，以检测数据是否被篡改。
    - 压缩和编码：在传输大量二进制数据时，可以考虑使用压缩算法来减少数据的传输量。同时，还可以使用编码方案（如Base64）将二进制数据转换为可打印字符，以便在文本协议中传输。
    - 安全性：对于敏感数据的二进制传输，需要考虑数据的加密和身份验证。可以使用加密算法对数据进行加密，以保护数据的机密性。同时，还可以使用数字签名或证书来验证数据的来源和完整性。






### 04.如何避免精度丢失
#### 4.1 先说一个业务



#### 4.2 BigDecimal介绍
- 为了避免精度丢失，可以使用BigDecimal类进行精确的十进制计算。BigDecimal提供了高精度的十进制运算，但需要注意它的性能相对较低。



#### 4.3 BigDecimal原理





### 07.float和double
- 为何 float 和 double 的计算输出结果差异还挺大的呢？
    - 附加题的话就是float和double所占的字节不同，他们的计算精度也不同。最关键的是保留有效数字的规则不同，十进制中我们是“4舍5入”，而二进制中是“0舍1入”。
    - 所以在上面的0.3f（转化为二进制保留8位小数是0.01001101），0.6f（转化为二进制保留8位小数是0.10011010），加起来是0.11100111，转化为十进制是0.90234375，所以 float 和 double 的计算输出结果差异还挺大的是因为保留有效数字时的“0舍1入”造成的。



### 08.浮点型表示法
- 计算机中的表示方法
    - 对于float来说，4个字节，32位，0-22位表示尾数，23-30(8位)表示指数，31位表示符号位。
    - 对于double来说，8个字节，64位，0-51表示尾数，52-62(11位)表示指数，63位最高位表示符号位。
- 具体分析表示方法
    - 以一道例题开始
    ```
    public static void main(String[] args) {
        float f1=20f;
        float f2=20.3f;
        float f3=20.5f;
    
        double d1=20;
        double d2=20.3;
        double d3=20.5;
    
        System.out.println(f1==d1);
        System.out.println(f2==d2);
        System.out.println(f3==d3);
    }
    
    true
    false
    true
    ```
- 20表示方式
    - 表示如下：注意，指数位要移位存储，即float+127(2^7-1),double+1023(2^10-1)
    ```
    f:0|1000 0011|0100 0000 0000 0000 0000 000
    d:0|100 0000 0011|0100 0000(01后面50个0)
    ```
    - 比较的时候是以符号位，指数位，小数位分别比较的，不足的地方以0补齐，所以相等，符号位均为0；指数位float减去127，并在前面补0，double减去1023；尾数位，float末尾补0。所以相等。
- 20.3表示方式
    - 1.十进制数转化为二进制数
        - 如何将十进制转换成二进制浮点数呢, 先介绍一下十进制的浮点数 转换二进制的浮点数，分为两部分：
            - 先将整数部分转换为二进制，
            - 将小数部分转换为二进制， 然后将整数部分与小数部分相加。
        - 以 20.3 转换为例
            - 20转换后变为 10100
            - 0.3要转换二进制，需要乘2，乘完之后取整数部分，然后用乘的结果减去整数部分， 然后 接着乘2, 直至最后没有小数或者小数出现循环, 即乘完.
            ```
            20 = 10100 (二进制)
            0.3 * 2= 0.6 (0)
            0.6 * 2 = 1.2 (1)
            0.2 * 2= 0.4 (0)
            0.4 * 2 = 0.8 (0)
            0.8 *2 = 1.6 (1)
            ```
        - 计算到这里， 将再出现0.6,进入循环了，所以，结果
            - 0.3 = 0.010011001…1001
            - 所以20.3 = 10100.010011001…1001 (二进制).
    - 2.二进制数转化为科学计数法
        - 20.3 = 10100.010011001…1001(二进制)=1.01000100110011E10…..（十进制科学计数）=1.01000100110011E100…..(二进制科学计数)
        - 这里使用移位存储，对于float来说，指数位加上127，double位加上1023(这里指的是存储，在比较的时候要分别减去127和1023)



#### 学习
- Java学习之double类型数据比较
    - https://blog.csdn.net/u012235651/article/details/73199464









