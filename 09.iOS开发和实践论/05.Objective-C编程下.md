# Objective-C编程下
#### 目录介绍
- 08.枚举的设计和使用
  - 8.1 枚举的定义
  - 8.2 枚举的使用
- 09.协议设计和使用
  - 9.1 协议的作用
  - 9.2 协议的声明
  - 9.3 协议使用步骤
  - 9.4 协议实际案例
  - 9.5 协议使用场景
- 10.理解动态类型设计
  - 10.1 理解动态类型
  - 10.2 理解id类型
  - 10.3 动态类型检查
  - 10.4 动态类型转化
  - 10.5 动态类型调用
  - 10.6 动态类型弊端
- 11.类别如何使用
  - 11.1 理解类别机制
  - 11.2 类别使用场景
  - 11.3 类别使用案例


## 08.枚举的设计和使用
### 8.1 枚举的定义

定义枚举类型：使用typedef enum关键字来定义枚举类型。在定义时，可以列出枚举的所有可能取值。

```
typedef enum {
    OptionA,
    OptionB,
    OptionC
} MyEnum;
```

枚举常量的默认值：如果没有为枚举常量指定具体的值，它们将按照顺序从0开始自动分配值。第一个常量的默认值为0，后续常量的值依次递增。

### 8.2 枚举的使用

使用枚举常量：定义枚举后，可以使用枚举常量来表示不同的取值。枚举常量的命名通常使用大写字母开头，以便与其他常量区分。

```
MyEnum myValue = OptionB;
```


## 09.协议设计和使用
### 9.1 协议的作用

协议（Protocol）是一种定义接口的机制，用于声明一组方法、属性或其他成员，以便其他类遵循（adopt）并实现（implement）。

协议的作用是定义了一套规范，使得不同的类可以遵循相同的接口，从而实现代码的重用和解耦。

### 9.2 协议的声明

```
//@protocol 是用于声明协议（Protocol）的关键字。协议定义了一组方法，用于描述类或对象应该遵循的行为和功能。
@protocol MyProtocol

//协议中的方法声明与类中的方法声明类似，使用以下语法：- (返回类型)方法名;

- (void) doSomething;
- (NSString *) getName;

@end
```

### 9.3 协议使用步骤

在实践中，可以按照以下步骤使用协议：

1. 定义协议：使用@protocol关键字定义协议，并在其中声明需要的方法、属性等。 
2. 遵循协议：在类的声明中使用<ProtocolName>来遵循特定的协议。 
3. 实现协议方法：在类的实现中，根据协议的要求实现相应的方法。 
4. 使用协议：通过协议类型的指针或引用，可以调用协议中定义的方法，而不需要关心具体的类。

### 9.4 协议实际案例

```
// 遵循协议的类
@interface MyClass : NSObject <MyProtocol>
@end

@implementation MyClass
- (void)doSomething {
    NSLog(@"Doing something...");
}
@end

// 使用协议
MyClass *myObject = [[MyClass alloc] init];
id<MyProtocol> objectWithProtocol = myObject;
[objectWithProtocol doSomething];
```

### 9.5 协议使用场景

协议（Protocol）具有广泛的使用场景，以下是一些常见的协议使用场景：

1. 委托模式（Delegate Pattern）：协议常用于实现委托模式，其中一个类（委托方）将某些任务委托给另一个类（委托对象）来处理。
2. 数据源模式（Data Source Pattern）：协议可以用于实现数据源模式，其中一个类（数据源）提供数据给另一个类（数据使用者）。
3. 视图控制器之间的通信：协议可以用于视图控制器之间的通信，例如一个视图控制器需要将数据传递给另一个视图控制器。
4. 网络请求回调：协议可以用于处理网络请求的回调，例如在网络请求完成后通知调用方。

## 10.理解动态类型设计

### 10.1 理解动态类型

动态类型是指在运行时确定对象的类型，而不是在编译时确定。Objective-C是一种动态类型语言，它允许在运行时进行类型检查和类型转换。

### 10.2 理解id类型

id类型：id是Objective-C中的一种特殊类型，表示一个未知类型的对象。

可以将任何对象赋值给id类型的变量，而不需要进行编译时的类型检查。在运行时，可以使用动态类型检查和消息传递来操作id类型的对象。

```
//1.未知类型的对象：当你不确定一个对象的具体类型时，可以使用id类型来存储该对象的引用。
id unknownObject = someObject;

//2.动态类型检查：通过将对象赋值给id类型的变量，可以使用动态类型检查方法来判断对象的具体类型。
if ([unknownObject isKindOfClass:[NSString class]]) {
    // 对象是NSString类型
} else if ([unknownObject isKindOfClass:[NSNumber class]]) {
    // 对象是NSNumber类型
}

//3.动态方法调用：使用id类型可以在运行时动态调用对象的方法，而不需要在编译时知道方法的具体实现。
id someObject = [SomeClass new];
[someObject performSelector:@selector(someMethod)];

//泛型集合：在Objective-C中，可以使用id类型来实现泛型集合，以存储不同类型的对象。
NSArray<id> *genericArray = @[object1, object2, object3];
```

要注意的是，由于id类型是一种未知类型，编译器无法提供类型检查和自动补全等功能。因此，在使用id类型时，需要确保在运行时进行适当的类型检查，以避免潜在的类型错误。

### 10.3 动态类型检查

动态类型检查：Objective-C提供了一些方法来进行动态类型检查，例如isKindOfClass:和isMemberOfClass:。

这些方法可以在运行时检查对象的类型，判断对象是否属于特定的类或其子类。

```
//该方法用于检查一个对象是否是指定类或其子类的实例。它会遍历整个继承链，包括父类和祖先类。
if ([someObject isKindOfClass:[NSString class]]) {
    // 对象是NSString类型或其子类的实例
}

//该方法用于检查一个对象是否是指定类的实例，而不包括其子类。
if ([someObject isMemberOfClass:[NSString class]]) {
    // 对象是NSString类型的实例，不包括其子类
}
```

如果需要检查对象是否遵循特定的协议，可以使用conformsToProtocol:方法。

```
if ([someObject conformsToProtocol:@protocol(MyProtocol)]) {
    // 对象遵循MyProtocol协议
}
```

### 10.4 动态类型转化

动态类型转换：Objective-C提供了一些方法来进行动态类型转换，例如isKindOfClass:和respondsToSelector:。

这些方法可以在运行时检查对象的类型，并根据需要将对象转换为其他类型。

```
//可以使用respondsToSelector:方法来检查对象是否实现了特定的方法。
if ([someObject respondsToSelector:@selector(someMethod)]) {
    // 对象实现了someMethod方法
}
```

### 10.5 动态类型调用


### 10.6 动态类型弊端

动态类型的特性使得Objective-C具有灵活性和可扩展性。它允许在运行时根据实际情况进行类型检查和类型转换，以适应不同的需求和场景。

但需要注意，过度使用动态类型可能会导致代码的可读性和可维护性下降，因此需要谨慎使用。

## 11.类别如何使用
### 11.1 理解类别机制

类别（Category）是一种机制，用于在不修改原始类的情况下扩展类的功能。类别允许开发者向现有类添加新的方法，以及修改或重写现有方法的实现。

### 11.2 类别使用场景

1.扩展类的功能：类别允许在不创建子类或修改原始类的情况下，向现有类添加新的方法。这对于向系统类或第三方库的类添加自定义功能非常有用。

2.方法重写：类别可以重写原始类中的方法实现。当类别中的方法与原始类中的方法同名时，类别中的方法会覆盖原始类中的方法。这使得可以通过类别来修改现有方法的行为。

3.避免命名冲突：在使用类别时，需要注意避免与其他类别或原始类中的方法产生命名冲突。最好使用特定的前缀或命名约定来命名类别中的方法，以确保命名的唯一性。

### 11.3 类别使用案例

下面是一个简单的示例，演示了如何使用类别来扩展NSString类的功能：

```
// 假设有一个名为 NSString+CustomMethods 的类别文件
@interface NSString (CustomMethods)

//反转字符串
- (NSString *)reversedString;

@end

@implementation NSString (CustomMethods)

- (NSString *)reversedString {
    NSMutableString *reversedString = [NSMutableString string];
    for (NSInteger i = self.length - 1; i >= 0; i--) {
        [reversedString appendString:[NSString stringWithFormat:@"%C", [self characterAtIndex:i]]];
    }
    return reversedString;
}

@end

int main(int argc, char * argv[]) {
    @autoreleasepool {
        NSString *originalString = @"Hello, World!";
        NSString *reversedString = [originalString reversedString];
        NSLog(@"%@", reversedString); // 输出：!dlroW ,olleH
    }
    return 0;
}
```










