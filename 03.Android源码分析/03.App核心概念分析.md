# 03.App核心概念分析
#### 目录介绍
- 01.App进程启动流程
  - 1.1 启动流程概述
  - 1.2 Android根进程
  - 1.3 Zygote进程流程
  - 1.4 SystemServer进程
  - 1.5 应用进程启动
- 02.ActivityThread
  - 2.1 它的作用描述
  - 2.2 核心流程分析
  - 2.3 主要功能有哪些
  - 2.4 启动Looper线程
  - 2.5 启动Application
  - 2.6 启动Activity流程
- 03.Context上下文
  - 3.1 Context设计目的
  - 3.2 Context分类设计
  - 3.3 Context创建流程
  - 3.4 Activity上下文
  - 3.5 组件中上下文总结
- 04.Android组件设计
  - 4.1 AMS核心设计思想
  - 4.2 Binder设计思想
  - 4.3 组件通信设计
  - 4.4 组件通信Intent




## 00.问题答疑思考

- App进程：说一下App进程启动流程？Zygote进程的启动流程是什么样的？关于Zygote进程主要做了那些事情？
- App进程：SystemServer进程启动流程是什么样的？怎么创建单个进程(application)？如何启动ActivityThread？
- 启动入口：ActivityThread启动入口做了什么？如何创建上下文？为什么要创建上下文。说一下主线程创建时机？
- 启动流程：说一下application的启动流程，何时创建，什么时候调用onCreate和attachBaseContext方法？
- 启动顺序：Application中attachBaseContext方法，onCreate方法和ContentProvider中的onCreate方法执行的顺序是什么？

## 01.App进程启动流程

### 1.1 启动流程概述

将Android系统的启动分成八层（或者说八个大步骤）

- 按下电源时引导芯片从代码从预定义的地方（固化在在Rom）开始执行，加载引导程序BootLoaer到RAM。
- BootLoader程序把系统OS拉起来并运行。
- Linux内核启动，这里面我们最关心的是init进程的启动，它是所有用户进程的鼻祖。
- 初始化init进程，这里面最重要的是启动Zygote进程，它是所有APP 进程的鼻祖（或者说是Java进程）。
- 初始化Zygote进程，创建运行APP所需要的服务，例如Java虚拟机、注册JNI方法以及启动SystemServer进程。
- 初始化SystemServer进程，这里最重要的就是启动Binder线程池以及一些核心服务，比如PMS、WMS、AMS等。
- AMS是管理Android 四大组件的核心服务，系统启动后会让AMS将系统桌面（也就是Launcher）加载出来。
- Launcher作为所有APP 的入口，点击Launcher上的图标后就会启动APP（如果APP进程不在，会先Fork Zygote进程来创建新进程）。

### 1.2 Android根进程

Zygote进程是所有的android进程的父进程，包括SystemServer和各种应用进程都是通过Zygote进程fork出来的。Zygote（孵化）进程相当于是android系统的根进程，后面所有的进程都是通过这个进程fork出来的。

init进程 --> Zygote进程 --> SystemServer进程 -->各种应用进程

1. init进程：linux的根进程，android系统是基于linux系统的，因此可以算作是整个android操作系统的第一个进程；
2. Zygote进程：android系统的根进程，主要作用：可以作用Zygote进程fork出SystemServer进程和各种应用进程；
3. SystemService进程：主要是在这个进程中启动系统的各项服务，比如ActivityManagerService，PackageManagerService，WindowManagerService服务等等；
4. 各种应用进程：启动自己编写的客户端应用时，一般都是重新启动一个应用进程，有自己的虚拟机与运行环境；

### 1.3 Zygote进程流程

Zygote进程的启动流程。具体代码位置：frameworks/base/core/java/com/android/internal/os/ZygoteInit.java

Zygote进程充当了应用进程的模板，避免了每个应用都需要重新加载和初始化系统类和资源的开销。这样可以大大提高应用的启动速度和系统资源的利用效率。同时，Zygote进程还通过共享内存区域和进程复制的方式，实现了应用进程的快速创建和初始化。

> 1. ZygoteInit#main()，在入口main方法中，主要初始化资源，socket通信，fork出SystemServer进程，最后关闭socket通信。
> 2. ZygoteInit#preload()，在preload方法中，初始化需要的class类，初始化系统资源，初始化系统libraries，初始化文字资源，初始化web等。
> 3. ZygoteInit#forkSystemServer()，fork出SystemServer进程

### 1.4 SystemServer进程

SystemServer进程在Android系统中扮演着重要的角色，负责启动和管理系统的核心服务（比如AMS，PMS，WMS等），初始化系统资源（比如binder驱动），处理系统广播（开机广播，网络状态广播）以及管理系统权限（应用程序权限分配）。

SystemServer进程启动流程，一般java类都是从main方法开始阅读，如下所示：

- SystemServer#main()，只是new出一个SystemServer对象并执行其run方法
- SystemServer#run()，初始化时间，语言，locale。接着设置虚拟机运行内存，加载运行库。然后初始化AMS，PMS，WMS等。
- SystemServer#createSystemContext()，看到在SystemServer进程中也存在着Context对象，并且是通过ActivityThread.systemMain方法创建context的
- SystemServer#startBootstrapServices()，这个是启动核心服务的方法
    - SystemServiceManager#startService启动各种服务，看源码可知，这个是通过反射器构造方法创建出服务类，最后再添加到SystemServiceManager的服务列表数据
    - mSystemServiceManager#startService(ActivityManagerService.Lifecycle.class)，启动AMS服务，四大组件都需要通过其余系统交互
        - ActivityManagerService.Lifecycle#Lifecycle()，静态内部类，在其构造方法中会创建一个ActivityManagerService
    - mSystemServiceManager.startService(PowerManagerService.class)，启动PMS，主要是屏幕，电源等相关
    - PackageManagerService.main(mSystemContext, installer,……)，启动PMS服务，该服务关联到apk文件的安装，解析，删除，卸载等等

### 1.5 应用进程启动



## 02.ActivityThread

### 2.1 它的作用描述

ActivityThread启动入口，这里面很多服务会用到mSystemContext上下文，那么这个上下文是做什么的呢？

通过ActivityThread创建，然后在获取Context对象，可以理解上下文Context为Android的基础环境信息。

这里很重要的一点是，在createSystemContext创建上下文时，启动了ActivityThread，该类既是App启动分析入口。

整个Android应用进程的体系非常复杂，ActivityThread是真正的核心类，它的main方法，是整个应用进程的入口。

为什么我们平时都将ActivityThread称之为ui线程或者是主线程。这里可以看出，应用进程被创建之后首先执行的是ActivityThread的main方法，所以我们将ActivityThread成为主线程。

### 2.2 核心流程分析

看一下ActivityThread核心方法

> ActivityThread#main()，程序启动入口，主要执行了一些初始化的逻辑，并且创建了一个UI线程消息队列
> ActivityThread#Looper.prepareMainLooper()，初始化Looper，App其实就是一个大的轮训器，处理所有的handler消息。
> ActivityThread#thread.attach()，在attach方法中，使用AMS启动核心逻辑，创建Application并执行生命周期onCreate调用

APP启动流程可以分三个阶段：

- Launcher请求AMS阶段。
- AMS到ApplicationThread的调用过程。
- ActivityThread启动Activity过程。

### 2.3 主要功能有哪些

ActivityThread是Android系统中负责管理应用程序生命周期和处理UI事件的关键组件。它是每个应用进程中的主线程，负责处理与Activity、Service、BroadcastReceiver等组件相关的操作。

1. 应用程序生命周期管理：ActivityThread负责管理应用程序的生命周期，包括应用的启动、暂停、恢复、停止和销毁等阶段。它通过与ActivityManagerService进行通信，接收来自系统的生命周期回调，并相应地调用应用程序中的相应方法。
2. Activity管理和调度：ActivityThread负责管理应用程序中的Activity实例。它负责创建、启动、暂停、恢复、停止和销毁Activity，并处理Activity之间的切换和交互。
3. 消息处理和线程调度：ActivityThread使用Handler和Looper机制来处理消息和线程调度。它负责处理来自系统和应用程序的消息，并将其分发给相应的处理器进行处理。
4. 应用程序上下文管理：ActivityThread负责管理应用程序的上下文，包括全局的Context对象和资源访问。它提供了应用程序级别的上下文，供应用程序中的各个组件使用。

ActivityThread是应用程序与系统之间的桥梁，确保应用程序的正常运行和用户交互的顺畅体验。

### 2.4 启动Looper线程

在main方法中主要执行了一些初始化的逻辑，并且创建了一个UI线程消息队列，这也就是为什么我们可以在主线程中随意的创建Handler而不会报错的原因，这里提出一个问题，大家可以思考一下：子线程可以创建Handler么？可以的话应该怎么做？

```java
public static void main(String[] args) {
    //初始化Looper
    Looper.prepareMainLooper();
    //开启loop循环
    Looper.loop();

    throw new RuntimeException("Main thread loop unexpectedly exited");
}
```

ActivityThread创建了一个Looper对象，并启动了消息循环。Looper负责管理消息队列和消息的分发，使得应用程序能够接收和处理来自系统和应用的消息。

这样，应用程序可以通过Handler机制来实现异步操作、UI更新和线程间通信等功能。

### 2.5 启动Application

App点击桌面图片启动过程

![image](https://upload-images.jianshu.io/upload_images/4432347-75aaec2032f31d55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

大概流程如下所示

> ActivityManagerService#startProcessLocked()
> Process#start()
> ActivityThread#main()，入口分析的地方
> ActivityThread#attach()，这个里面的逻辑很核心
> ActivityManagerService#attachApplication()，通过Binder机制调用了ActivityManagerService的attachApplication
> ActivityManagerService#attachApplicationLocked()，整个应用进程已经启动起来了
> ActivityManagerService#thread.bindApplication，具体回到ActivityThread
> ActivityThread.ApplicationThread#bindApplication()，最后看到sendMessage处理bind逻辑
> ActivityThread#handleBindApplication()，设置进程的pid，初始化进程信息
> ActivityThread#mInstrumentation.callApplicationOnCreate，看到Application进入onCreate()方法中，这就是从最开始main()方法开始到最后的Application的onCreate（）的创建过程


### 2.6 启动Activity流程



## 03.Context上下文

### 3.1 Context设计目的

Android设计了Context上下文的概念，是为了提供应用程序访问系统资源和执行特定操作的接口。Context在Android开发中扮演着重要的角色，具有以下几个主要目的：

1. 访问系统资源：Context允许应用程序访问系统级别的资源，如应用程序的包名、资源文件、数据库、SharedPreferences、系统服务等。通过Context，应用程序可以获取这些资源并进行相应的操作，如读取配置信息、加载布局文件、访问数据库等。

2. 启动组件：Context提供了启动Activity、Service、BroadcastReceiver等组件的能力。通过Context，应用程序可以启动其他组件，并传递相应的参数和意图。这使得应用程序能够进行界面跳转、后台服务启动、广播发送等操作。

3. 获取应用程序级别的信息：Context提供了获取应用程序级别信息的能力，如应用程序的包名、应用程序的资源、应用程序的文件目录等。这些信息对于应用程序的自身管理和配置非常有用。

4. 访问系统服务：Context允许应用程序访问系统级别的服务，如网络服务、传感器服务、位置服务等。通过Context，应用程序可以获取这些服务的实例，并使用其提供的功能和数据。

5. 安全性和权限管理：Context在Android中也用于安全性和权限管理。通过Context，应用程序可以获取自身的权限信息、检查和请求权限，并确保应用程序在运行时获得适当的权限。

通过Context，应用程序可以获取系统资源、启动组件、获取应用程序级别的信息、访问系统服务以及进行安全性和权限管理。这使得应用程序能够与Android系统进行有效的交互和操作。


### 3.2 Context分类设计

Context被设计为一个抽象类，并有多个具体的子类来表示不同的上下文。这些子类主要用于提供不同的功能和访问级别，以满足应用程序在不同场景下的需求。

Application Context（应用程序上下文）：它是全局唯一的上下文，代表整个应用程序的生命周期。它的生命周期与应用程序的生命周期相同，从应用程序启动到关闭。Application Context可以用于获取应用程序级别的资源、访问数据库、执行全局操作等。

Activity Context（活动上下文）：它是特定Activity的上下文，与Activity的生命周期绑定。Activity Context提供了访问Activity相关资源和执行Activity特定操作的能力，如启动其他Activity、访问Activity的布局、获取Intent等。

Service Context（服务上下文）：它是特定Service的上下文，与Service的生命周期绑定。Service Context提供了访问Service相关资源和执行Service特定操作的能力，如访问Service的布局、获取Intent等。

Broadcast Receiver Context（广播接收器上下文）：它是特定Broadcast Receiver的上下文，与Broadcast Receiver的生命周期绑定。Broadcast Receiver Context提供了访问Broadcast Receiver相关资源和执行Broadcast Receiver特定操作的能力，如获取广播Intent、发送广播等。

Content Provider Context（内容提供器上下文）：它是特定Content Provider的上下文，与Content Provider的生命周期绑定。Content Provider Context提供了访问Content Provider相关资源和执行Content Provider特定操作的能力，如访问数据库、执行数据查询等。

这些不同类型的Context提供了不同级别和范围的功能和访问权限，以满足应用程序在不同场景下的需求。

### 3.3 Context创建流程

Context创建流程

通过ActivityThread类的成员函数performLaunchActivity在应用程序进程中创建一个Activity实例，并且为它设置运行上下文环境，即为它创建一个ContextImpl对象。

### 3.4 Activity上下文

Android应用程序窗口的运行上下文环境是通过ContextImpl类来描述的，即每一个Activity组件都关联有一个ContextImpl对象。

![image](https://img-blog.csdnimg.cn/f01624ded7b14201b870217fb5624d5e.png)

Activity组件通过其父类ContextThemeWrapper和ContextWrapper的成员变量mBase来引用了一个ContextImpl对象。

这样，Activity组件以后就可以通过这个ContextImpl对象来执行一些具体的操作，例如，启动Service组件、注册广播接收者和启动Content Provider组件等操作。

![image](https://img-blog.csdnimg.cn/31f9b74ee10644a4ac6ce2952d567c93.png)

比较重要的流程介绍
>ActivityThread.handleLaunchActivity()
>ActivityThread.performLaunchActivity()
>mInstrumentation.newActivity 使用反射创建Activity
>activity.attach 这里会调用Activity中attach方法
>Activity.attach()
>mWindow = new PhoneWindow 这里创建所属的PhoneWindow
>mWindow.setWindowManager  设置并获取 WindowManagerImpl 对象

Android应用程序窗口的运行上下文环境的创建过程

第一步：ActivityThread#performLaunchActivity()，主要看mInstrumentation.newActivity()的过程。Instrumentation类是用来记录应用程序与系统的交互过程的

- 要启动的Activity组件的类名保存在变量component。有了这个类名之后，函数就可以调用ActivityThread类的成员变量mInstrumentation所描述一个Instrumentation对象的成员函数newActivity来创建一个Activity组件实例了，并且保存变量activity中。

第二步：ActivityThread#createBaseContextForActivity，这里是创建ContextImpl的步骤

- 这里最终会调用到ContextImpl#createActivityContext，通过new创建该impl对象，且进行初始化附值操作。

第三步：Instrumentation#newActivity()，这个是创建activity的过程。
- 这里是通过ClassLoader去load具体的要加载的类的className，得到一个Class对象。
- 由于className描述的是一个Activity子类，因此，当函数调用前面得到的Class对象的成员函数newInstance的时候，就会创建一个Activity子类实例。
- 第四步：new Activity，第二步通过反射创建activity对象，创建对象是必须通过构造函数创建的
- 一般来说，一个类的构造函数是用来初始化该类的实例的，系统为Activity类提供的默认构造函数什么也不做，也就是说，Activity类实例在创建的时候，还没有执行实质的初始化工作。
- 第五步：appContext.setOuterContext()，还是在performLaunchActivity方法里面，看看做了什么
- 即ActivityThread类的成员函数performLaunchActivity中，接下来就会调用ContextImpl类的成员函数setOuterContext来设置前面所创建一个ContextImpl对象所关联的一个Activity组件，即正在启动的Activity组件。
- 一个ContextImpl对象所关联的一个Activity组件是通过调用ContextImpl类的成员函数setOuterContext来设置的。
- setOuterContext只是简单地将它保存在成员变量mContext中，以表明当前正在处理的一个ContextImpl对象是用来描述一个Activity组件的运行上下文环境的。
- 第六步：activity.attach()，这里是真正进入到Activity初始化的过程
- 初始化一个Activity组件实例需要一个Application对象app、一个ContextImpl对象appContext以及一个Configuration对象config，它们分别用来描述该Activity组件实例的应用程序信息、运行上下文环境以及配置信息。
- 最开始是调用Activity#attachBaseContext()方法，这个我们看下面的第七步。
- 接着创建了一个PhoneWindow，并且保存在Activity类的成员变量mWindow中。这个PhoneWindow是用来描述当前正在启动的应用程序窗口的。
- 这个应用程序窗口在运行的过程中，会接收到一些事件，例如，键盘、触摸屏事件等，这些事件需要转发给与它所关联的Activity组件处理，这个转发操作是通过一个Window.Callback接口来实现的。
- 参数info指向的是一个ActivityInfo对象，用来描述当前正在启动的Activity组件的信息。其中，这个ActivityInfo对象的成员变量softInputMode用来描述当前正在启动的一个Activity组件是否接受软键盘输入。
- 第七步：ContextThemeWrapper.attachBaseContext()，接着第六步往下分析
- 由调用Activity#attachBaseContext()方法分析，最终会调用到ContextThemeWrapper#attachBaseConext。
- ContextThemeWrapper类用来维护一个应用程序窗口的主题，而用来描述这个应用程序窗口的运行上下文环境的一个ContextImpl对象就保存在ContextThemeWrapper类的成员函数mBase中。
- 第八步：ContextWrapper.attachBaseContext()，，接着第七步往下分析
- ContextWrapper类只是一个代理类，它只是简单地封装了对其成员变量mBase所描述的一个Context对象的操作。
- ContextWrapper类的成员函数attachBaseContext的实现很简单，它只是将参数base所描述的一个ContextImpl对象保存在成员变量mBase中。这样，ContextWrapper类就可以将它的功能交给ContextImpl类来具体实现。
- 第九步：Instrumentation#callActivityOnCreate()，主要是执行activity的生命周期onCreate
- 函数主要就是调用当前正在启动的Activity组件的成员函数onCreate，用来通知它已经成功地创建和启动完成了。
- 第十步：Activity#onCreate()，这里会回调Activity的方法，也是开发的入口
- 一般来说，我们都是通过定义一个Activity子类来实现一个Activity组件的。重写父类Activity的某些成员函数的时候，必须要回调父类Activity的这些成员函数。
- 例如，当Activity子类在重写父类Activity的成员函数onCreate时，就必须回调父类Activity的成员函数onCreate。这些成员函数被回调了之后，Activity类就会将其成员变量mCalled的值设置为true。这样，Activity类就可以通过其成员变量mCalled来检查其子类在重写它的某些成员函数时，是否正确地回调了父类的这些成员函数。


### 3.5 组件中上下文总结

一个Activity组件的创建过程，以及它的运行上下文环境的创建过程。这个过程比较简单，我们是从中获得以下三点信息：

- 一个Android应用窗口的运行上下文环境是使用一个ContextImpl对象来描述的，这个ContextImpl对象会分别保存在Activity类的父类ContextThemeWrapper和ContextWrapper的成员变量mBase中，即ContextThemeWrapper类和ContextWrapper类的成员变量mBase指向的是一个ContextImpl对象。
- Activity组件在创建过程中，即在它的成员函数attach被调用的时候，会创建一个PhoneWindow对象，并且保存在成员变量mWindow中，用来描述一个具体的Android应用程序窗口。
- Activity组件在创建的最后，即在它的子类所重写的成员函数onCreate中，会调用父类Activity的成员函数setContentView来创建一个Android应用程序窗口的视图。

## 04.Android组件设计

组件化设计实现：程序由组件组成；组件与进程剥离；组件皆程序入口

程序由组件组成：Activity：前台交互；Service：后台计算；Broadcast Receiver：广播通信；Content Provider：数据封装

组件与进程剥离：组件关闭时，进程可以继续存在，提高重新启动时的速度；进程关闭时，组件可以继续存在，保护被杀进程里面的组件。

将组件与进程进行剥离，使得进程对组件透明，听起来很好，但是如何解决以下四个问题？

- 谁来负责组件的启动和关闭？
- 谁来维护组件的状态？
- 谁来管理组件运行时所需要的进程？
- 组件之间如何进行通信？


### 4.1 AMS核心设计思想

Android AMS（Activity Manager Service）是Android操作系统中的一个核心组件，负责管理应用程序的生命周期、任务栈、进程和应用间的交互等。

启动组件，组件启动时，检查其所要运行在的进程是否已创建。如果已经创建，就直接通知它加载组件。否则，先将该进程创建起来，再通知它加载组件。

关闭组件，组件关闭时，其所运行在的进程无需关闭，这样就可以让组件重新打开时得到快速启动。

维护组件状态，维护组件在运行过程的状态，这样组件就可以在其所运行在的进程被回收的情况下仍然继续生存。

进程管理

- 在适当的时候主动回收空进程和后台进程，以及通知进程自己进行内存回收
- 组件的UID和Process Name唯一决定了其所要运行在的进程。
- 每次组件onStop时，都会将自己的状态传递给AMS维护。

AMS在以下四种情况下会调用trimApplications来主动回收进程：

- A.activityStopped，停止Activity
- B.setProcessLimit，设置进程数量限制
- C.unregisterReceiver，注销Broadcast Receiver
- D.finishReceiver，结束Broadcast Receiver

WMS也会主动回收进程：WindowManagerService在处理窗口的过程中发生Out Of Memroy时，会调用reclaimSomeSurfaceMemoryLocked来回收某些Surface占用的内存，reclaimSomeSurfaceMemoryLocked的逻辑如下所示：

- (1).首先检查有没有泄漏的Surface，即那些Session已经不存在但是还没有销毁的Surface，以及那些宿主Activity已经不可见但是还没有销毁的Surface。如果存在的话，就将它们销毁即可，不用KillPids。
- (2).如果不存在没有泄漏的Surface，那么那些存在Surface的进程都有可能被杀掉，这是通过KillPids来实现的。

### 4.2 Binder设计思想

为组件间通信提供支持：进程间；进程内

高效的IPC机制

1. 进程间的组件通信时，通信数据只需一次拷贝
2. 进程内的组件通信时，跳过IPC进行直接的通信

传统的IPC，通信数据需要执行两次，一次是从源进程的用户空间拷贝到内核空间，二次是从内核空间拷贝到目标进程的用户空间

### 4.3 组件通信设计

组件之间的通信是通过Intent、Broadcast、回调和共享数据等方式实现的。以下是Android中常见的组件通信设计：

1. Intent（意图）：Intent是用于在组件之间传递消息和执行操作的对象。通过在Intent中设置数据和标识符，可以实现不同组件之间的通信和交互。
2. Broadcast（广播）：Broadcast是一种系统级别的消息机制，用于在应用程序内部或与其他应用程序之间进行通信。
3. 回调（Callback）：回调是一种通过接口或抽象类定义的方法，用于在组件之间进行回调通知。
4. 共享数据（Shared Data）：组件之间可以通过共享数据来进行通信。Android提供了ContentProvider机制，允许应用程序共享和访问数据。
5. 组件间直接引用：在某些情况下，组件之间可以直接引用彼此，以实现更紧密的通信。这种方式适用于组件之间需要频繁交互和共享状态的场景。

### 4.4 组件通信Intent












