# C++入门到精通中
#### 目录介绍
- 06.函数
  - 6.1 概述和定义
  - 6.2 函数调用
  - 6.3 值传递
  - 6.4 函数常见样式
  - 6.5 函数声明
  - 6.6 函数分文件编写
  - 6.7 函数重载
- 07.指针和引用
  - 7.1 指针概念
  - 7.2 指针变量定义
  - 7.3 指针占用内存空间
  - 7.4 空指针和野指针
  - 7.5 const修饰指针
  - 7.6 指针和数组
  - 7.7 指针和函数
  - 7.8 指针数据&函数
  - 7.9 引用定义和使用
  - 7.10 引用和函数



## 06.函数

### 6.1 概述和定义

**作用**：将一段经常使用的代码封装起来，减少重复代码

一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。

函数的定义一般主要有5个步骤：

- 1、返回值类型
- 2、函数名
- 3、参数表列
- 4、函数体语句
- 5、return 表达式

**语法：**

```cpp
返回值类型 函数名 （参数列表）{
       函数体语句
       return表达式

}
```

* 返回值类型 ：一个函数可以返回一个值。在函数定义中
* 函数名：给函数起个名称
* 参数列表：使用该函数时，传入的数据
* 函数体语句：花括号内的代码，函数内需要执行的语句
* return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据

**示例：**定义一个加法函数，实现两个数相加

```cpp
//函数定义
int add(int num1, int num2) {
    int sum = num1 + num2;
    return sum;
}
```

### 6.2 函数调用

**功能**：使用定义好的函数

**语法：**` 函数名（参数）`

**示例：**

```cpp
//定义中的num1,num2称为形式参数，简称形参
int add(int num1, int num2) {
    int sum = num1 + num2;
    return sum;
}

int main() {
    int a = 10;
    int b = 10;
    //调用add函数
    int sum = add(a, b); //调用时的a，b称为实际参数，简称实参
    cout << "sum = " << sum << endl;
    a = 100;
    b = 100;
    sum = add(a, b);
    cout << "sum = " << sum << endl;
    return 0;
}
```

> 总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参

形式参数是函数或方法定义中声明的参数，也称为函数的参数列表。它们是在函数或方法定义时指定的占位符，用于接收传递给函数或方法的实际参数的值。

实际参数是在函数或方法调用时传递给形式参数的具体值。它们是实际传递给函数或方法的数据

### 6.3 值传递

* 所谓值传递，就是函数调用时实参将数值传入给形参
* 值传递时，==如果形参发生，并不会影响实参==

**示例：**

```cpp
void swap(int num1, int num2){
    cout << "交换前：" << endl;
    cout << "num1 = " << num1 << endl;
    cout << "num2 = " << num2 << endl;

    int temp = num1;
    num1 = num2;
    num2 = temp;

    cout << "交换后：" << endl;
    cout << "num1 = " << num1 << endl;
    cout << "num2 = " << num2 << endl;
    //return ; 当函数声明时候，不需要返回值，可以不写return
}

int main() {
    int a = 10;
    int b = 20;
    swap(a, b);
    cout << "mian中的 a = " << a << endl;
    cout << "mian中的 b = " << b << endl;
    return 0;
}
```

然后打印一下结果，如下所示

```text
交换前：
num1 = 10
num2 = 20
交换后：
num1 = 20
num2 = 10
mian中的 a = 10
mian中的 b = 20
```

> 总结： 值传递时，形参是修饰不了实参的

在C++中，值传递（Pass by Value）是一种参数传递的方式，它指的是将实际参数的值复制给函数或方法的形式参数。在值传递中，函数或方法使用的是形式参数的副本，而不是直接操作实际参数本身。

1. 形式参数是实际参数的副本：在函数或方法调用时，实际参数的值会被复制到对应的形式参数中。这意味着函数或方法内部对形式参数的修改不会影响到实际参数的值。
2. 独立的内存空间：值传递会在内存中为形式参数分配独立的内存空间，这样函数或方法可以在其内部使用和修改这些副本，而不会影响到实际参数。
3. 不会改变实际参数的值：由于值传递使用的是形式参数的副本，函数或方法对形式参数的修改不会影响到实际参数的值。
4. 如果需要在函数或方法中修改实际参数的值，可以考虑使用引用传递或指针传递。

### 6.4 函数常见样式

常见的函数样式有4种

1. 无参无返
2. 有参无返
3. 无参有返
4. 有参有返

**示例：**

```cpp
//1、 无参无返
void test01() {
    //void a = 10; //无类型不可以创建变量,原因无法分配内存
    cout << "this is test01" << endl;
    //test01(); 函数调用
}

//2、 有参无返
void test02(int a) {
    cout << "this is test02" << endl;
    cout << "a = " << a << endl;
}

//3、无参有返
int test03() {
    cout << "this is test03 " << endl;
    return 10;
}

//4、有参有返
int test04(int a, int b) {
    cout << "this is test04 " << endl;
    int sum = a + b;
    return sum;
}

int main() {
    test01();
    test02(10);
    int a3 = test03();
    int a4 = test04(1,3);
    return 0;
}
```

### 6.5 函数声明

**作用：** 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

函数的**声明可以多次**，但是函数的**定义只能有一次**

**示例：**

```cpp
//声明可以多次，定义只能一次
//声明
int max(int a, int b);
int max(int a, int b);
//定义
int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    int a = 100;
    int b = 200;
    cout << max(a, b) << endl;
    return 0;
}
```

函数声明的目的是为了在使用函数之前，让编译器知道函数的存在和基本信息，以便进行语法检查和类型检查。这样可以在不同的源文件中分离函数的声明和定义，使得代码更加模块化和可维护。

1. 返回类型：指定函数的返回值类型，可以是基本数据类型、自定义类型或void（表示没有返回值）。 
2. 函数名：指定函数的名称，用于在代码中调用该函数。 
3. 参数列表：指定函数的参数类型和参数名称，用于接收传递给函数的实际参数。


### 6.6 函数分文件编写

**作用**：让代码结构更加清晰。它将函数的声明和定义分别放置在不同的文件中。这种方式可以提高代码的可维护性、可读性和可重用性。

函数分文件编写一般有4个步骤

1. 创建后缀名为.h的头文件
2. 创建后缀名为.cpp的源文件
3. 在头文件中写函数的声明
4. 在源文件中写函数的定义

**示例：**

.h的头文件中声明

```cpp
//.h文件
#include<iostream>
using namespace std;

//实现两个数字交换的函数声明
void swap(int a, int b);
```

.cpp的头文件中实现

```cpp
void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
}

int main() {
    int a = 100;
    int b = 200;
    swap(a, b);
    return 0;
}
```

### 6.7 函数重载

函数重载（Function Overloading）是指在同一个作用域内，可以定义多个同名函数，但它们的参数列表不同。函数重载允许使用相同的函数名来实现不同的功能！

1. 函数名相同：重载函数具有相同的函数名，但参数列表不同。 
2. 参数列表不同：参数列表可以通过参数的类型、个数或顺序的不同来区分。 
3. 返回类型不是重载的依据：函数重载不依赖于函数的返回类型，只依赖于参数列表。

```cpp
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}

int add(int a, int b, int c) {
    return a + b + c;
}

int main() {
    int result1 = add(3, 5); // 调用第一个add函数
    double result2 = add(2.5, 3.7); // 调用第二个add函数
    int result3 = add(1, 2, 3); // 调用第三个add函数
    return 0;
}
```

函数重载使得代码更加灵活，可以根据不同的需求使用相同的函数名来实现不同的功能。

## 07.指针和引用

### 7.1 指针概念

**指针的作用：** 可以通过指针间接访问内存

* 内存编号是从0开始记录的，一般用十六进制数字表示
* 可以利用指针变量保存地址

指针，它存储了一个内存地址。指针可以指向其他变量或对象的内存地址，允许直接访问或操作这些变量或对象。指针的概念可以通过以下几个要点来理解：

1. 内存地址：指针存储的是一个内存地址，这个地址指向某个变量或对象在内存中的位置。可以将指针看作是一个存储了内存地址的变量。
2. 取址操作符（&）：通过使用取址操作符（&），可以获取变量或对象的内存地址。例如，int x = 5; int* ptr = &x; 将 ptr 指向变量 x 的内存地址。
3. 解引用操作符：通过使用解引用操作符，可以访问指针所指向的内存地址上存储的值。例如，int value = *ptr; 将获取指针 ptr 所指向的内存地址上存储的值，并将其赋给 value。
4. 空指针：指针还可以具有空值，即不指向任何有效的内存地址。空指针可以用 nullptr 表示。
5. 动态内存分配：指针在动态内存分配中非常有用。通过使用 new 运算符，可以在堆上分配内存，并返回指向该内存的指针。使用 delete 运算符可以释放动态分配的内存。

### 7.2 指针变量定义

指针变量定义语法： `数据类型 * 变量名；`

**示例：**

```cpp
int main() {
    int a = 10; //定义整型变量a
    //1、指针的定义
    //指针定义语法： 数据类型 * 变量名 ;
    int * p;
    //指针变量赋值
    p = &a; //指针指向变量a的地址
    cout << &a << endl; //打印数据a的地址
    cout << p << endl;  //打印指针变量p

    //2、指针的使用
    //通过*操作指针变量指向的内存
    cout << "*p = " << *p << endl;
    return 0;
}
```

指针变量和普通变量的区别

* 普通变量存放的是数据,指针变量存放的是地址
* 指针变量可以通过" * "操作符，操作指针变量指向的内存空间，这个过程称为解引用

1. 总结1： 我们可以通过 & 符号 获取变量的地址 
2. 总结2：利用指针可以记录地址 
3. 总结3：对指针变量解引用，可以操作指针指向的内存


### 7.3 指针占用内存空间

提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？**示例：**

```cpp
int main() {
    int a = 10;
    int * p;
    p = &a; //指针指向数据a的地址

    cout << *p << endl; //* 解引用
    cout << sizeof(p) << endl;
    cout << sizeof(char *) << endl;
    cout << sizeof(float *) << endl;
    cout << sizeof(double *) << endl;\
    return 0;
}
//10
//8
//8
//8
//8
```

在 C++ 中，指针的大小取决于编译器和操作系统的位数。通常情况下，指针在 C++ 中也会占用一定的内存空间，这个空间大小与系统的位数相关。

在大多数现代计算机系统中，指针的大小通常如下：

32 位系统：在 32 位系统中，指针通常占用 4 个字节（32 位）的内存空间。

64 位系统：在 64 位系统中，指针通常占用 8 个字节（64 位）的内存空间。

### 7.4 空指针和野指针

**空指针**：空指针是指不指向任何有效内存地址的指针。空指针通常用来表示指针没有被初始化或者指向了无效的内存地址。在 C++ 中，空指针的值通常是 0 或者使用 nullptr 关键字表示。

**用途**：初始化指针变量

**注意**：空指针指向的内存是不可以访问的

**示例1：空指针**

```cpp
int main() {
	//指针变量p指向内存地址编号为0的空间
	int * p = NULL;
	//访问空指针报错 
	//内存编号0 ~255为系统占用内存，不允许用户访问
	cout << *p << endl;
	return 0;
}
```

**野指针**：指针变量指向非法的内存空间

**示例2：野指针**

```cpp
int main() {
	//指针变量p指向内存地址编号为0x1100的空间
	int * p = (int *)0x1100;
	//访问野指针报错 
	cout << *p << endl;
	return 0;
}
```

> 总结：空指针和野指针都不是我们申请的空间，因此不要访问。





### 7.5 const修饰指针


### 7.6 指针和数组


### 7.7 指针和函数


### 7.8 指针数据&函数


### 7.9 引用定义和使用


### 7.10 引用和函数



































