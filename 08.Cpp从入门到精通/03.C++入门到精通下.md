# C++入门到精通下
#### 目录介绍
- 13.多线程和并发
- 14.线程安全锁
- 15.内存分配堆和栈
  - 15.1 内存分区模型
    - 15.1.1 理解代码区
    - 15.1.2 理解全局区
    - 15.1.3 理解栈区
    - 15.1.4 理解堆区
    - 15.1.5 内存模型用例
  - 15.2 理解动态内存
    - 15.2.1 何为动态内存
    - 15.2.2 动态内存特点
    - 15.2.3 new分配内存
    - 15.2.4 delete释放内存
    - 15.2.5 内存泄漏
    - 15.2.6 野指针
- 16.IO流和文件
- 17.异常处理
- 18.STL标准库模版


## 15.内存分配堆和栈

### 15.1 内存分区模型

C++程序在执行时，将内存大方向划分为**4个区域**

- 代码区：存放函数体的二进制代码，由操作系统进行管理的
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等
- 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收

#### 15.1.1 理解代码区

作用： 存储程序的二进制代码（即编译后的机器指令）。

特点： 1.只读，程序运行时不可修改。 2.由操作系统管理，程序结束时释放。

```cpp
void func() {
// 函数代码存储在代码区
}
```

#### 15.1.2 理解全局区

全局/静态区（Global/Static Segment）作用：

1. 存储全局变量、静态变量（包括静态局部变量和静态成员变量）。 
2. 分为两个子区域： 已初始化区：存储已初始化的全局变量和静态变量。 未初始化区（BSS 段）：存储未初始化的全局变量和静态变量。

特点：1.在程序启动时分配，程序结束时释放。 2.未初始化的变量会被自动初始化为 0。

```cpp
int globalVar = 10; // 已初始化全局变量，存储在全局区
static int staticVar; // 未初始化静态变量，存储在 BSS 段
void func() {
    static int localStaticVar = 20; // 静态局部变量，存储在全局区
}
```

#### 15.1.3 理解栈区

栈区（Stack Segment） 作用： 存储局部变量、函数参数、函数返回地址等。

特点：

1. 由编译器自动管理，函数调用时分配，函数返回时释放。
2. 内存分配和释放速度快，但空间有限。
3. 栈的大小通常较小（默认几 MB），如果栈溢出会导致程序崩溃。

```cpp
void func() {
    int localVar = 30; // 局部变量，存储在栈区
}
```


#### 15.1.4 理解堆区

堆区（Heap Segment） 作用： 存储动态分配的内存（如 new 和 malloc 分配的内存）。

特点：

1. 由程序员手动管理，需要显式释放（如 delete 或 free）。
2. 内存分配和释放速度较慢，但空间较大。
3. 如果未正确释放内存，会导致内存泄漏。

```cpp
void func() {
    int* ptr = new int(40); // 动态分配内存，存储在堆区
    delete ptr; // 手动释放内存
}
```

### 15.1.5 内存模型用例

内存分区模型的特点

1. 代码区：只读，存储程序指令。
2. 全局/静态区：存储全局和静态变量，生命周期与程序相同。
3. 栈区：存储局部变量和函数调用信息，自动管理，空间有限。
4. 堆区：存储动态分配的内存，手动管理，空间较大。

```cpp
#include <iostream>

int globalVar = 10; // 全局变量，存储在全局区
static int staticVar; // 静态变量，存储在 BSS 段

void func() {
    int localVar = 30; // 局部变量，存储在栈区
    static int localStaticVar = 20; // 静态局部变量，存储在全局区
    int* ptr = new int(40); // 动态分配内存，存储在堆区
    std::cout << "Local Variable: " << localVar << std::endl;
    std::cout << "Dynamic Memory: " << *ptr << std::endl;
    delete ptr; // 释放堆区内存
}

int main() {
    func();
    return 0;
}
```

### 15.2 理解动态内存

#### 15.2.1 何为动态内存

动态内存是指程序在运行时（而不是编译时）从堆区（Heap）分配的内存。

动态内存的管理由程序员手动控制，通过 new 和 delete 操作符（或 C 风格的 malloc 和 free）来分配和释放内存。

#### 15.2.2 动态内存特点

运行时分配： 内存的分配和释放发生在程序运行时，而不是编译时。

手动管理： 程序员需要显式分配和释放内存，否则会导致内存泄漏。

堆区存储： 动态内存从堆区分配，堆区的空间通常比栈区大。

灵活性： 动态内存的大小可以在运行时动态调整，适合处理不确定大小的数据。

#### 15.2.3 new分配内存

C++中利用==new==操作符在堆区开辟数据

堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==

语法：` new 数据类型`

利用new创建的数据，会返回该数据对应的类型的指针

分配单个对象：

```cpp
class MyClass {
public:
    MyClass() {
        std::cout << "MyClass constructor called" << std::endl;
    }

    MyClass(int age, string name) {
        this->age = age;
        this->name = name;
        std::cout << "MyClass constructor " << this->age << " , " << this->name << std::endl;
    }

    ~MyClass() {
        std::cout << "MyClass destructor called" << std::endl;
    }

public:
    int age;
    string name;
};

void test1() {
    // 使用new运算符创建MyClass对象
    MyClass* obj = new MyClass();
    // 使用对象指针调用对象的成员函数
    // ...
    // 释放动态分配的内存
    delete obj;
}

void test2() {
    MyClass* obj = new MyClass(30,"yc");
    delete obj;
}

int main() {
//    test1();
    test2();
    return 0;
}
```

#### 15.2.4 delete释放内存

#### 15.2.5 内存泄漏

#### 15.2.6 野指针


常见问题
栈溢出：
如果递归调用过深或局部变量过多，会导致栈溢出。
解决方法：优化递归，减少局部变量，或增加栈大小。
内存泄漏：
如果动态分配的内存未释放，会导致内存泄漏。
解决方法：确保每次 new 都有对应的 delete。
野指针：
如果访问已释放的内存，会导致未定义行为。
解决方法：释放内存后将指针置为 nullptr。













