#### 目录介绍
- 01.HTTP请求准备
  - 1.1 确定请求方法
  - 1.2 构建请求URL
  - 1.3 HTTP请求准备
- 02.HTTP请求构建
  - 2.1 请求报文规范
  - 2.2 创建请求行
  - 2.3 设置请求头
  - 2.4 添加请求体
- 03.HTTP请求发送
  - 3.1 建立网络链接
  - 3.2 发送请求头
  - 3.3 发送请求体
  - 3.4 等待服务器响应
- 04.HTTP返回构建
  - 4.1 构建响应码
  - 4.2 构建响应头
  - 4.3 构建响应体
  - 4.4 发送响应数据
- 05.页面加载和渲染
  - 5.1 解析HTML
  - 5.2 加载外部资源
  - 5.3 渲染页面
  - 5.4 布局和绘制
  - 5.5 页面加载完成



## 01.HTTP请求准备

### 1.1 确定请求方法


### 1.2 构建请求URL

HTTP协议，几乎是每个人上网用的第一个协议，同时也是很容易被人忽略的协议。

既然说看新闻，咱们就先登录http://www.163.com。http://www.163.com是个URL，叫作统一资源定位符。

之所以叫统一，是因为它是有格式的。HTTP称为协议，www.163.com是一个域名，表示互联网上的一个位置。有的URL会有更详细的位置标识，

例如http://www.163.com/index.html 正是因为这个东西是统一的，所以当你把这样一个字符串输入到浏览器的框里的时候，浏览器才知道如何进行统一处理。

### 1.3 HTTP请求准备

浏览器会将 www.163.com 这个域名发送给DNS服务器，让它解析为IP地址。有关DNS的过程，其实非常复杂，这里先不管，反正它会被解析成为IP地址。那接下来是发送HTTP请求吗？

不是的，HTTP是基于TCP协议的，当然是要先建立TCP连接了，怎么建立呢？还记得三次握手吗？

目前使用的HTTP协议大部分都是1.1。在1.1的协议里面，默认是开启了Keep-Alive的，这样建立的TCP连接，就可以在多次请求中复用。

学习了TCP之后，你应该知道，TCP的三次握手和四次挥手，还是挺费劲的。如果好不容易建立了连接，然后就做了一点儿事情就结束了，有点儿浪费人力和物力。

## 02.HTTP请求构建

### 2.1 请求报文规范

建立了连接以后，浏览器就要发送HTTP的请求，请求的格式就像这样。

![image](https://static.geekbang.org/infoq/5c94a9fa2a1fb.png)

HTTP的报文大概分为三大部分。

第一部分是请求行，第二部分是请求的首部，第三部分才是请求的正文实体。


### 2.2 创建请求行

在请求行中，URL就是 http://www.163.com，版本为HTTP 1.1。这里要说一下的，就是方法。方法有几种类型呢？

对于访问网页来讲，最常用的类型就是GET。顾名思义，GET就是去服务器获取一些资源。对于访问网页来讲，要获取的资源往往是一个页面。其实也有很多其他的格式，比如说返回一个JSON字符串，到底要返回什么，是由服务器端的实现决定的。

另外一种类型叫做POST。它需要主动告诉服务端一些信息，而非获取。要告诉服务端什么呢？一般会放在正文里面。正文可以有各种各样的格式。常见的格式也是JSON。

还有一种类型叫PUT，就是向指定资源位置上传最新内容。但是，HTTP的服务器往往是不允许上传文件的，所以PUT和POST就都变成了要传给服务器东西的方法。

在实际使用过程中，这两者还会有稍许的区别。POST往往是用来创建一个资源的，而PUT往往是用来修改一个资源的。例如，云主机已经创建好了，我想对这个云主机打一个标签，说明这个云主机是生产环境的，另外一个云主机是测试环境的。那怎么修改这个标签呢？往往就是用PUT方法。

再有一种常见的就是DELETE。这个顾名思义就是用来删除资源的。例如，我们要删除一个云主机，就会调用DELETE方法。

### 2.3 设置请求头

请求行下面就是我们的首部字段。首部是key value，通过冒号分隔。这里面，往往保存了一些非常重要的字段。

1. 例如，Accept-Charset，表示客户端可以接受的字符集，防止传过来的是另外的字符集，从而导致出现乱码。
2. 再如，Content-Type是指正文的格式。例如，我们进行POST的请求，如果正文是JSON，那么我们就应该将这个值设置为JSON。

这里需要重点说一下的就是缓存。为啥要使用缓存呢？

那是因为一个非常大的页面有很多东西。例如，我浏览一个商品的详情，里面有这个商品的价格、库存、展示图片、使用手册等等。商品的展示图片会保持较长时间不变，而库存会根据用户购买的情况经常改变。如果图片非常大，而库存数非常小，如果我们每次要更新数据的时候都要刷新整个页面，对于服务器的压力就会很大。

在HTTP头里面，Cache-control是用来控制缓存的。当客户端发送的请求中包含max-age指令时，如果判定缓存层中，资源的缓存时间数值比指定时间的数值小，那么客户端可以接受缓存的资源；当指定max-age值为0，那么缓存层通常需要将请求转发给应用集群。

目前为止，我们仅仅是拼凑起来了HTTP请求的报文格式，接下来，浏览器会把它交给下一层传输层。怎么交给传输层呢？其实也无非是用Socket这些东西，只不过用的浏览器里，这些程序不需要你自己写，有人已经帮你写好了。

### 2.4 添加请求体


## 03.HTTP请求发送

### 3.1 建立网络链接

浏览器使用TCP/IP协议与服务器建立网络连接。这涉及到解析主机名为IP地址、建立TCP连接等步骤。

在HTTP中，建立网络连接涉及到客户端和服务器之间的通信过程。以下是HTTP建立网络连接的一般步骤：

1. 客户端发起连接：客户端（例如浏览器）向服务器发起连接请求。这通常是通过建立TCP连接来实现的，使用服务器的IP地址和端口号。 
2. 服务器响应连接：服务器接收到客户端的连接请求后，可以选择接受或拒绝连接。如果服务器接受连接，它会发送一个确认响应给客户端。 
3. TCP握手：一旦服务器确认连接，客户端和服务器之间进行TCP握手。这是一个三次握手的过程，用于建立可靠的双向通信通道。

### 3.2 发送请求头

浏览器将构建好的HTTP请求头发送给服务器。发送请求头是客户端向服务器发送包含请求信息的头部字段的过程。常见的请求头部字段包括：

1. User-Agent：标识客户端的用户代理，通常是浏览器的名称和版本号。 
2. Accept：指定客户端能够接受的响应内容类型，如文本、图像、视频等。 
3. Content-Type：指定请求体中的数据类型，如表单数据、JSON、XML等。 
4. Authorization：用于身份验证的凭据，如基本身份验证的用户名和密码。 
5. Cookie：包含客户端的Cookie信息，用于会话跟踪和状态管理。 
6. Referer：指示请求的来源页面的URL。 
7. Cache-Control：指定缓存策略，如是否允许缓存、缓存的有效期等。

添加其他自定义头部字段：根据需要，可以添加其他自定义的头部字段，以传递额外的请求信息。

将请求头部字段添加到请求中：将构建好的请求头部字段添加到HTTP请求中。这通常是通过在请求的头部部分添加相应的字段行来实现的。

发送请求：将包含请求头部的完整HTTP请求发送给服务器。这可以通过TCP连接发送请求报文来实现。

### 3.3 发送请求体

1. 构建请求体数据：根据需要，构建包含请求数据的请求体。请求体可以是各种格式的数据，如表单数据、JSON、XML等。
2. 编码请求体数据：根据请求体的数据格式，对数据进行适当的编码。例如，对表单数据可以使用URL编码，对JSON数据可以使用JSON编码。
3. 设置Content-Type头部字段：在请求头部中设置Content-Type字段，指定请求体数据的类型。例如，对于表单数据，Content-Type可以是application/x-www-form-urlencoded；对于JSON数据，可以是application/json。
4. 将编码后的请求体数据添加到请求中：将编码后的请求体数据添加到HTTP请求中的请求体部分。这通常是在请求的头部和请求体之间使用一个空行分隔，然后将请求体数据放置在空行之后。
5. 发送请求：将包含请求体的完整HTTP请求发送给服务器。这可以通过TCP连接发送请求报文来实现。

### 3.4 等待服务器响应

在HTTP中，发送请求后，客户端通常需要等待服务器的响应。以下是一般的等待服务器响应的过程：

1. 发送请求：客户端将构建好的HTTP请求发送给服务器。这可以通过TCP连接发送请求报文来实现。
2. 等待服务器响应：一旦请求发送完成，客户端会进入等待状态，等待服务器的响应。这期间，客户端的连接保持打开状态，以便接收服务器的响应。
3. 服务器处理请求：服务器接收到客户端的请求后，会根据请求的内容和服务器上的资源进行处理。这可能涉及数据库查询、计算、文件读写等操作，具体处理时间取决于服务器的性能和负载情况。 
4. 生成响应：服务器处理完请求后，会生成相应的HTTP响应。响应包括状态码、头部字段和响应体。

到了第四步之后，就会去返回构建信息。

## 04.HTTP返回构建

### 4.1 构建响应码


### 4.2 构建响应头


### 4.3 构建响应体


### 4.4 发送响应数据

## 05.页面加载和渲染

### 5.1 解析HTML


### 5.2 加载外部资源


### 5.3 渲染页面


### 5.4 布局和绘制


### 5.5 页面加载完成






### 04.HTTP请求发送
- HTTP协议是基于TCP协议的，所以它使用面向连接的方式发送请求，通过stream二进制流的方式传给对方。当然，到了TCP层，它会把二进制流变成一个的报文段发送给服务器。在发送给每个报文段的时候，都需要对方有一个回应ACK，来保证报文可靠地到达了对方。如果没有回应，那么TCP这一层会进行重新传输，直到可以到达。同一个包有可能被传了好多次，但是HTTP这一层不需要知道这一点，因为是TCP这一层在埋头苦干。
- TCP层发送每一个报文的时候，都需要加上自己的地址（即源地址）和它想要去的地方（即目标地址），将这两个信息放到IP头里面，交给IP层进行传输。
- IP层需要查看目标地址和自己是否是在同一个局域网。如果是，就发送ARP协议来请求这个目标地址对应的MAC地址，然后将源MAC和目标MAC放入MAC头，发送出去即可。如果不在同一个局域网，就需要发送到网关，还要需要发送ARP协议，来获取网关的MAC地址，然后将源MAC和网关MAC放入MAC头，发送出去。
- 网关收到包发现MAC符合，取出目标IP地址，根据路由协议找到下一跳的路由器，获取下一跳路由器的MAC地址，将包发给下一跳路由器。这样路由器一跳一跳终于到达目标的局域网。这个时候，最后一跳的路由器能够发现，目标地址就在自己的某一个出口的局域网上。于是，在这个局域网上发送ARP，获得这个目标地址的MAC地址，将包发出去。
- 目标的机器发现MAC地址符合，就将包收起来；发现IP地址符合，根据IP头中协议项，知道自己上一层是TCP协议，于是解析TCP的头，里面有序列号，需要看一看这个序列包是不是我要的，如果是就放入缓存中然后返回一个ACK，如果不是就丢弃。
- TCP头里面还有端口号，HTTP的服务器正在监听这个端口号。于是，目标机器自然知道是HTTP服务器这个进程想要这个包，于是将包发给HTTP服务器。HTTP服务器的进程看到，原来这个请求是要访问一个网页，于是就把这个网页发给客户端。



### 05.HTTP返回构建
- HTTP的返回报文也是有一定格式的。这也是基于HTTP 1.1的。
    - ![image](https://static.geekbang.org/infoq/5c94a9f8cf246.png)
- 状态码会反应HTTP请求的结果。
    - “200”意味着大吉大利；而我们最不想见的，就是“404”，也就是“服务端无法响应这个请求”。然后，短语会大概说一下原因。
- 接下来是返回首部的key value。
    - 这里面，Retry-After表示，告诉客户端应该在多长时间以后再次尝试一下。“503错误”是说“服务暂时不再和这个值配合使用”。
- 在返回的头部里面也会有Content-Type，表示返回的是HTML，还是JSON。
- 构造好了返回的HTTP报文，接下来就是把这个报文发送出去。还是交给Socket去发送，还是交给TCP层，让TCP层将返回的HTML，也分成一个个小的段，并且保证每个段都可靠到达。这些段加上TCP头后会交给IP层，然后把刚才的发送过程反向走一遍。虽然两次不一定走相同的路径，但是逻辑过程是一样的，一直到达客户端。
- 客户端发现MAC地址符合、IP地址符合，于是就会交给TCP层。根据序列号看是不是自己要的报文段，如果是，则会根据TCP头中的端口号，发给相应的进程。这个进程就是浏览器，浏览器作为客户端也在监听某个端口。
- 当浏览器拿到了HTTP的报文。发现返回“200”，一切正常，于是就从正文中将HTML拿出来。HTML是一个标准的网页格式。浏览器只要根据这个格式，展示出一个绚丽多彩的网页。
- 这就是一个正常的HTTP请求和返回的完整过程。


### 06.HTTP 2.0介绍
- 当然HTTP协议也在不断地进化过程中，在HTTP1.1基础上便有了HTTP 2.0。
- HTTP 1.1在应用层以纯文本的形式进行通信。每次通信都要带完整的HTTP的头，而且不考虑pipeline模式的话，每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题。
- 为了解决这些问题，HTTP 2.0会对HTTP的头进行一定的压缩，将原来每次都要携带的大量key value在两端建立一个索引表，对相同的头只发送索引表中的索引。
- 另外，HTTP 2.0协议将一个TCP的连接中，切分成多个流，每个流都有自己的ID，而且流可以是客户端发往服务端，也可以是服务端发往客户端。它其实只是一个虚拟的通道。流是有优先级的。
- HTTP 2.0还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。常见的帧有Header帧，用于传输Header内容，并且会开启一个新的流。再就是Data帧，用来传输正文实体。多个Data帧属于同一个流。
- 通过这两种机制，HTTP 2.0的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。这些帧可以打散乱序发送， 然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。
- 我们来举一个例子。假设我们的一个页面要发送三个独立的请求，一个获取css，一个获取js，一个获取图片jpg。如果使用HTTP 1.1就是串行的，但是如果使用HTTP 2.0，就可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应。
    - ![image](https://static.geekbang.org/infoq/5c94a9feb5b0f.png)
- HTTP 2.0其实是将三个请求变成三个流，将数据分成帧，乱序发送到一个TCP连接中。
    - ![image](https://static.geekbang.org/infoq/5c94a9fb56717.png)
- HTTP 2.0成功解决了HTTP 1.1的队首阻塞问题，同时，也不需要通过HTTP 1.x的pipeline机制用多条TCP连接来实现并行请求与响应，减少了TCP连接数对服务器性能的影响，同时将页面的多个数据css、js、 jpg等通过一个数据链接进行传输，能够加快页面组件的传输速度。















