# 07.Socket的发展和设计
#### 目录介绍
- 01.通信基础概念
  - 1.1 Socket基础理解
  - 1.2 TCP/IP协议简介
  - 1.3 Socket与Http对比
  - 1.4 Socket使用类型
  - 1.5 Socket和ServerSocket
  - 1.6 一些问题思考
- 02.Socket必备概念
  - 2.5 理解四元组
- 03.TCP协议Socket
- 04.UDP协议Socket
- 05.Socket实践思路
  - 5.1 基础实践步骤
  - 5.2 Socket连接
  - 5.3 Socket中tls连接
  - 5.4 Socket数据读写
  - 5.5 Socket断开连接
  - 5.6 Socket完整案例


## 01.通信基础概念
### 1.1 Socket基础理解
- Socket定义
  - 即套接字，是应用层 与 TCP/IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API）。
- 核心要点
  - Socket不是一种协议，而是一个编程调用接口（API），属于传输层（主要解决数据如何在网络中传输）
  - 通过Socket，我们才能在Android平台上通过 TCP/IP协议进行开发；对用户来说，只需调用Socket去组织数据，以符合指定的协议，即可通信。


### 1.2 TCP/IP协议简介
- IP
  - IP 协议提供了主机和主机间的通信。为了完成不同主机的通信，我们需要某种方式来唯一标识一台主机，这个标识，就是著名的IP地址。通过IP地址，IP 协议就能够帮我们把一个数据包发送给对方。
- TCP
  - TCP 协议在 IP 协议提供的主机间通信功能的基础上，完成这两个主机上进程对进程的通信。
- Port
  - 为了标识数据属于哪个进程，我们给需要进行 TCP 通信的进程分配一个唯一的数字来标识它。这个数字，就是我们常说的端口号。


### 1.3 Socket与Http对比
- 不属于同一层面
  - Socket属于传输层，因为 TCP / IP协议属于传输层，解决的是数据如何在网络中传输的问题
  - HTTP协议 属于 应用层，解决的是如何包装数据
- 工作方式的不同
  - Http：采用 请求—响应 方式。可理解为：是客户端有需要才进行通信；
  - Socket：采用 服务器主动发送数据 的方式。可理解为：是服务器端有需要才进行通信


### 1.4 Socket使用类型
- Socket的使用类型主要有两种：
  - 流套接字（streamsocket） ：基于 TCP协议，采用 流的方式 提供可靠的字节流服务
  - 数据报套接字(datagramsocket)：基于 UDP协议，采用 数据报文 提供数据打包发送的服务
- 具体原理图如下：
  - ![image](https://img-blog.csdnimg.cn/f030fc846dbe4154a4806093d8209b42.png)

### 1.5 Socket和ServerSocket
- Socket 和 ServerSocket 的区别是什么
  - 在 Java 的 SDK 中，socket 的共有两个接口：用于监听客户连接的 ServerSocket 和用于通信的 Socket。
- 那各自的使用场景是什么样的
  - Socket类代表一个客户端套接字，即任何时候连接到一个远程服务器应用时构建所需的socket。
  - ServerSocket，要实现一个服务器应用，需要不同的做法。服务器需随时待命，因为不知道客户端什么时候会发来请求，此时，需要使用ServerSocket。
  - ServerSocket与Socket不同，ServerSocket是等待客户端的请求，一旦获得一个连接请求，就创建一个Socket示例来与客户端进行通信。


### 1.6 一些问题思考

- Socket概念：Socket是如何通信的？跟Http有何区别？数据传递性能如何？是否具有安全性？
- Socket实践：Socket是如何使用的的？如何创建连接，读数据（接受）和写数据（发送）分别是怎么设计的？
- Socket实践：读数据的时候，如何将io字节流转化为特定的tcp数据，拿到tcp数据后如何解析数据(解析成对应实体bean)？
- Socket长链接：如何设置socket保持长链接？如何保持轮训心跳包稳定性并且不会阻塞主线程？如何理解心跳包？
- Socket读写：如何理解Socket读写数据？如何处理读写异常逻辑？异常之后如何设计重新连接？
- Socket数据：TcpPacket是如何设计的？消息的长度是不确定的，并且每条消息都有它的边界。我们如何来处理这个边界？
- Socket数据：如何保证数据有序性？一个任务队列，执行任务，如何保证先取出的任务，执行结果需要先放入结果队列？


## 02.Socket必备概念

### 2.5 理解四元组

四元组是指在网络通信中，用于唯一标识一个网络连接的四个要素，包括源IP地址、源端口号、目标IP地址和目标端口号。这四个要素共同构成了一个网络连接的唯一标识。

1. 源IP地址：指发起通信的主机的IP地址，用于标识数据包的来源。 
2. 源端口号：指发起通信的主机上的应用程序或进程使用的端口号。它是一个16位的数字，用于标识数据包在源主机上的具体应用程序或进程。 
3. 目标IP地址：指接收数据包的主机的IP地址，用于标识数据包的目的地。 
4. 目标端口号：指接收数据包的主机上的应用程序或进程监听的端口号。它也是一个16位的数字，用于标识数据包在目标主机上的具体应用程序或进程。


## 05.Socket实践思路

### 5.1 基础实践步骤
- Socket可基于TCP或者UDP协议，但TCP更加常用。所以下面的使用步骤 & 实例的Socket将基于TCP协议。
  - 第一步：创建客户端 & 服务器的连接。
  - 第二步：客户端 & 服务器 通信。
  - 第三步：断开客户端 & 服务器 连接。

### 5.2 Socket连接
- 第一步：创建客户端 & 服务器的连接。创建Socket对象 & 指定服务端的IP及端口号 ，判断客户端和服务器是否连接成功。
    ```
    // 创建Socket对象 & 指定服务端的IP及端口号 
    Socket socket = new Socket("192.168.1.32", 1989);  
    // 判断客户端和服务器是否连接成功  
    socket.isConnected();
    ```
- Socket连接条件
  - 需要指定ip地址和port端口号。然后调用`socket?.connect(address, timeOut)`


### 5.3 Socket中tls连接
- 这一步的作用主要是：增加安全性校验。


### 5.4 Socket数据读写
- 第二步：客户端 & 服务器 通信。通信包括：客户端 接收服务器的数据 & 发送数据到服务器
    ```
    <-- 操作1：接收服务器的数据 -->
    // 步骤1：创建输入流对象InputStream
    InputStream is = socket.getInputStream() 
    // 步骤2：创建输入流读取器对象 并传入输入流对象
    // 该对象作用：获取服务器返回的数据
    InputStreamReader isr = new InputStreamReader(is);
    BufferedReader br = new BufferedReader(isr);
    // 步骤3：通过输入流读取器对象 接收服务器发送过来的数据
    br.readLine()；
    
    <-- 操作2：发送数据 到 服务器 -->                  
    // 步骤1：从Socket 获得输出流对象OutputStream
    // 该对象作用：发送数据
    OutputStream outputStream = socket.getOutputStream(); 
    // 步骤2：写入需要发送的数据到输出流对象中
    outputStream.write（（"杨充"+"\n"）.getBytes("utf-8")）；
    // 特别注意：数据的结尾加上换行符才可让服务器端的readline()停止阻塞
    // 步骤3：发送数据到服务端 
    outputStream.flush();  
    ```


### 5.5 Socket断开连接
- 第三步：断开客户端 & 服务器 连接
    ```
    // 断开 客户端发送到服务器 的连接，即关闭输出流对象OutputStream
    os.close();
    // 断开 服务器发送到客户端 的连接，即关闭输入流读取器对象BufferedReader
    br.close();
    // 最终关闭整个Socket连接
    socket.close();
    ```

### 5.6 Socket完整案例
- TCP Socket分为Socket和ServerSocket对应着client和server，下面我来用代码实现一个简单的TCP通讯功能：
- 客户端：首先创建一个Socket和InetSocketAddress，然后通过Socket的connect()方法进行连接，连接成功后可以获取到输出流，通过该输出流就可以向服务端传输数据。
    ```
    public class TCPClient {
        public static void main(String[] args) throws IOException {
            //1.创建TCP客户端Socket服务
            Socket client = new Socket();
            //2.与服务端进行连接
            InetSocketAddress address = new InetSocketAddress("192.168.31.137",10000);
            client.connect(address);
            //3.连接成功后获取客户端Socket输出流
            OutputStream outputStream = client.getOutputStream();
            //4.通过输出流往服务端写入数据
            outputStream.write("hello server".getBytes());
            //5.关闭流
            client.close();
        }
    }
    ```
- 服务端：创建一个服务端Socket并明确端口号，通过accept()方法获取到链接过来的客户端Socket，从客户端Socket中获取输入流，最后由输入流读取客户端传输来的数据。
    ```
    public class TCPServer {
        public static void main(String[] args) throws IOException {
            //1.创建服务端Socket并明确端口号
            ServerSocket serverSocket = new ServerSocket(10000);
            //2.获取到客户端的Socket
            Socket socket = serverSocket.accept();
            //3.通过客户端的Socket获取到输入流
            InputStream inputStream = socket.getInputStream();
            //4.通过输入流获取到客户端传递的数据
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
            String line = null;
            while ((line = bufferedReader.readLine())!=null){
                System.out.println(line);
            }
            //5.关闭流
            socket.close();
            serverSocket.close();
        }
    }
    ```
- 一个服务端是可以同时和多个客户端进行通信的，那么它是如何区分不同客户端呢？
  - 从上面代码我们可以看到，服务端首先通过accept()获取到客户端Socket，然后通过客户端的Socket获取的流进行通讯，这也让服务端得以区分每个客户端。





### 01.Socket简单介绍
- Socket如何理解
    - Socket 这个名字很有意思，可以作插口或者插槽讲。虽然我们是写软件程序，但是你可以想象为弄一根网线，一头插在客户端，一头插在服务端，然后进行通信。所以在通信之前，双方都要建立一个 Socket。
    - 在建立 Socket 的时候，应该设置什么参数呢？Socket 编程进行的是端到端的通信，往往意识不到中间经过多少局域网，多少路由器，因而能够设置的参数，也只能是端到端协议之上网络层和传输层的。
    - 在网络层，Socket 函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。另外，还要指定到底是 TCP 还是 UDP。还记得咱们前面讲过的，TCP 协议是基于数据流的，所以设置为 SOCK_STREAM，而 UDP 是基于数据报的，因而设置为 SOCK_DGRAM。
- Socket简单介绍
	* Socket就是为网络服务提供的一种机制
	* 通信的两端都有Socket
	* 网络通信其实就是Socket间的通信
	* 数据在两个Socket间通过IO传输
	* 玩Socket主要就是记住流程，代码查文档就行
	* Socket的简单使用的话应该都会，两个端各建立一个Socket，服务端的叫ServerSocket，然后建立连接即可。



### 02.Socket工作图解
- 如下所示
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-81e16b1dba650de8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 03.Socket建立网络连接
- Socket建立网络连接的步骤是什么？
    - 建立Socket连接至少需要一对套接字，其中一个运行与客户端--ClientSocket，一个运行于服务端--ServiceSocket
        - 1、服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。
        - 2、客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。注意：客户端的套接字必须描述他要连接的服务器的套接字，
        - 指出服务器套接字的地址和端口号，然后就像服务器端套接字提出连接请求。
        - 3、连接确认：当服务器端套接字监听到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述
        - 发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务端套接字则继续处于监听状态，继续接收其他客户端套接字的连接请求。



### 04.TCP协议的Socket
- TCP 的服务端要先监听一个端口，一般是先调用 bind 函数，给这个 Socket 赋予一个 IP 地址和端口。为什么需要端口呢？要知道，你写的是一个应用程序，当一个网络包来的时候，内核要通过 TCP 头里面的这个端口，来找到你这个应用程序，把包给你。为什么要 IP 地址呢？有时候，一台机器会有多个网卡，也就会有多个 IP 地址，你可以选择监听所有的网卡，也可以选择监听一个网卡，这样，只有发给这个网卡的包，才会给你。
- 当服务端有了 IP 和端口号，就可以调用 listen 函数进行监听。在 TCP 的状态图里面，有一个 listen 状态，当调用这个函数之后，服务端就进入了这个状态，这个时候客户端就可以发起连接了。
- 在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态。
- 接下来，服务端调用 accept 函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。
- 在服务端等待的时候，客户端可以通过 connect 函数发起连接。先在参数中指明要连接的 IP 地址和端口号，然后开始发起三次握手。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的 accept 就会返回另一个 Socket。
- 这是一个经常考的知识点，就是监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作监听 Socket，一个叫作已连接 Socket。
- 连接建立成功之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。
- 这个图就是基于 TCP 协议的 Socket 程序函数调用过程。
    - ![image](https://img-blog.csdnimg.cn/20190409135611939.png)
- 说 TCP 的 Socket 就是一个文件流，是非常准确的。因为，Socket 在 Linux 中就是以文件的形式存在的。除此之外，还存在文件描述符。写入和读出，也是通过文件描述符。
- 在内核中，Socket 是一个文件，那对应就有文件描述符。每一个进程都有一个数据结构 task_struct，里面指向一个文件描述符数组，来列出这个进程打开的所有文件的文件描述符。文件描述符是一个整数，是这个数组的下标。
- 这个数组中的内容是一个指针，指向内核中所有打开的文件的列表。既然是一个文件，就会有一个 inode，只不过 Socket 对应的 inode 不像真正的文件系统一样，保存在硬盘上的，而是在内存中的。在这个 inode 中，指向了 Socket 在内核中的 Socket 结构。
- 在这个结构里面，主要的是两个队列，一个是发送队列，一个是接收队列。在这两个队列里面保存的是一个缓存 sk_buff。这个缓存里面能够看到完整的包的结构。看到这个，是不是能和前面讲过的收发包的场景联系起来了？
- 整个数据结构我也画了一张图。
    - ![image](https://img-blog.csdnimg.cn/20190409135633409.png)



### 05.UDP协议的Socket
- 对于 UDP 来讲，过程有些不一样。UDP 是没有连接的，所以不需要三次握手，也就不需要调用 listen 和 connect，但是，UDP 的的交互仍然需要 IP 和端口号，因而也需要 bind。UDP 是没有维护连接状态的，因而不需要每对连接建立一组 Socket，而是只要有一个 Socket，就能够和多个客户端通信。也正是因为没有连接状态，每次通信的时候，都调用 sendto 和 recvfrom，都可以传入 IP 地址和端口。
- 这个图的内容就是基于 UDP 协议的 Socket 程序函数调用过程。
    - ![image](https://img-blog.csdnimg.cn/20190409135739925.png)



### 06.服务器接更多项目
- 会了这几个基本的 Socket函数之后，你就可以轻松地写一个网络交互的程序了。就像上面的过程一样，在建立连接后，进行一个 while 循环。客户端发了收，服务端收了发。
- 当然这只是万里长征的第一步，因为如果使用这种方法，基本上只能一对一沟通。如果你是一个服务器，同时只能服务一个客户，肯定是不行的。这就相当于老板成立一个公司，只有自己一个人，自己亲自上来服务客户，只能干完了一家再干下一家，这样赚不来多少钱。
- 那作为老板你就要想了，我最多能接多少项目呢？当然是越多越好。我们先来算一下理论值，也就是最大连接数，系统会用一个四元组来标识一个 TCP 连接。
    ```
    {本机 IP, 本机端口, 对端 IP, 对端端口}
    ```
- 服务器通常固定在某个本地端口上监听，等待客户端的连接请求。因此，服务端端 TCP 连接四元组中只有对端 IP, 也就是客户端的 IP 和对端的端口，也即客户端的端口是可变的，因此，最大 TCP 连接数 = 客户端 IP 数×客户端端口数。对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数，约为 2 的 48 次方。
- 当然，服务端最大并发 TCP 连接数远不能达到理论上限。首先主要是文件描述符限制，按照上面的原理，Socket 都是文件，所以首先要通过 ulimit 配置文件描述符的数目；另一个限制是内存，按上面的数据结构，每个 TCP 连接都要占用一定内存，操作系统是有限的。
- 所以，作为老板，在资源有限的情况下，要想接更多的项目，就需要降低每个项目消耗的资源数目。



#### 6.1 将项目外包给其他公司
- 将项目外包给其他公司（多进程方式）
    - 这就相当于你是一个代理，在那里监听来的请求。一旦建立了一个连接，就会有一个已连接 Socket，这时候你可以创建一个子进程，然后将基于已连接 Socket 的交互交给这个新的子进程来做。就像来了一个新的项目，但是项目不一定是你自己做，可以再注册一家子公司，招点人，然后把项目转包给这家子公司做，以后对接就交给这家子公司了，你又可以去接新的项目了。
- 这里有一个问题是，如何创建子公司，并如何将项目移交给子公司呢？
    - 在 Linux 下，创建子进程使用 fork 函数。
    - 通过名字可以看出，这是在父进程的基础上完全拷贝一个子进程。在 Linux 内核中，会复制文件描述符的列表，也会复制内存空间，还会复制一条记录当前执行到了哪一行程序的进程。显然，复制的时候在调用 fork，复制完毕之后，父进程和子进程都会记录当前刚刚执行完 fork。这两个进程刚复制完的时候，几乎一模一样，只是根据 fork 的返回值来区分到底是父进程，还是子进程。如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。
- 进程复制过程我画在这里。
    - ![image](https://img-blog.csdnimg.cn/20190409140942762.png)
- 因为复制了文件描述符列表，而文件描述符都是指向整个内核统一的打开文件列表的，因而父进程刚才因为 accept 创建的已连接 Socket 也是一个文件描述符，同样也会被子进程获得。
- 接下来，子进程就可以通过这个已连接 Socket 和客户端进行互通了，当通信完毕之后，就可以退出进程，那父进程如何知道子进程干完了项目，要退出呢？还记得 fork 返回的时候，如果是整数就是父进程吗？这个整数就是子进程的 ID，父进程可以通过这个 ID 查看子进程是否完成项目，是否需要退出。



#### 6.2 将项目转包给独立的项目组
- 方式二：将项目转包给独立的项目组（多线程方式）
    - 上面这种方式你应该也能发现问题，如果每次接一个项目，都申请一个新公司，然后干完了，就注销掉这个公司，实在是太麻烦了。毕竟一个新公司要有新公司的资产，有新的办公家具，每次都买了再卖，不划算。
    - 于是你应该想到了，我们可以使用线程。相比于进程来讲，这样要轻量级的多。如果创建进程相当于成立新公司，购买新办公家具，而创建线程，就相当于在同一个公司成立项目组。一个项目做完了，那这个项目组就可以解散，组成另外的项目组，办公家具可以共用。
    - 在 Linux 下，通过 pthread_create 创建一个线程，也是调用 do_fork。不同的是，虽然新的线程在 task 列表会新创建一项，但是很多资源，例如文件描述符列表、进程空间，还是共享的，只不过多了一个引用而已。
    - ![image](https://img-blog.csdnimg.cn/20190409141014480.png)
- 新的线程也可以通过已连接 Socket 处理请求，从而达到并发处理的目的。
    - 上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程。一台机器无法创建很多进程或者线程。有个C10K，它的意思是一台机器要维护 1 万个连接，就要创建 1 万个进程或者线程，那么操作系统是无法承受的。如果维持 1 亿用户在线需要 10 万台服务器，成本也太高了。
    - 其实 C10K 问题就是，你接项目接的太多了，如果每个项目都成立单独的项目组，就要招聘 10 万人，你肯定养不起，那怎么办呢？



#### 6.3 一个项目组支撑多个项目
- 方式三：一个项目组支撑多个项目（IO 多路复用，一个线程维护多个 Socket）
    - 当然，一个项目组可以看多个项目了。这个时候，每个项目组都应该有个项目进度墙，将自己组看的项目列在那里，然后每天通过项目墙看每个项目的进度，一旦某个项目有了进展，就派人去盯一下。
    - 由于 Socket 是文件描述符，因而某个线程盯的所有的 Socket，都放在一个文件描述符集合 fd_set 中，这就是项目进度墙，然后调用 select 函数来监听文件描述符集合是否有变化。一旦有变化，就会依次查看每个文件描述符。那些发生变化的文件描述符在 fd_set 对应的位都设为 1，表示 Socket 可读或者可写，从而可以进行读写操作，然后再调用 select，接着盯着下一轮的变化。。


#### 6.4 一个项目组支撑多个项目
- 方式四：一个项目组支撑多个项目（IO 多路复用，从“派人盯着”到“有事通知”）
    - 上面 select 函数还是有问题的，因为每次 Socket 所在的文件描述符集合中有 Socket 发生变化的时候，都需要通过轮询的方式，也就是需要将全部项目都过一遍的方式来查看进度，这大大影响了一个项目组能够支撑的最大的项目数量。因而使用 select，能够同时盯的项目数量由 FD_SETSIZE 限制。
    - 如果改成事件通知的方式，情况就会好很多，项目组不需要通过轮询挨个盯着这些项目，而是当项目进度发生变化的时候，主动通知项目组，然后项目组再根据项目进展情况做相应的操作。
    - 能完成这件事情的函数叫 epoll，它在内核中的实现不是通过轮询的方式，而是通过注册 callback 函数的方式，当某个文件描述符发送变化的时候，就会主动通知。
    - ![image](https://img-blog.csdnimg.cn/20190409141024109.png)
- 如图所示，假设进程打开了 Socket m, n, x 等多个文件描述符，现在需要通过 epoll 来监听是否这些 Socket 都有事件发生。其中 epoll_create 创建一个 epoll 对象，也是一个文件，也对应一个文件描述符，同样也对应着打开文件列表中的一项。在这项里面有一个红黑树，在红黑树里，要保存这个 epoll 要监听的所有 Socket。
- 当 epoll_ctl 添加一个 Socket 的时候，其实是加入这个红黑树，同时红黑树里面的节点指向一个结构，将这个结构挂在被监听的 Socket 的事件列表中。当一个 Socket 来了一个事件的时候，可以从这个列表中得到 epoll 对象，并调用 call back 通知它。
- 这种通知方式使得监听的 Socket 数据增加的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了。上限就为系统定义的、进程打开的最大文件描述符个数。因而，epoll 被称为解决 C10K 问题的利器。







### 其他介绍

03丨套接字和地址：像电话和电话号码一样理解它们

https://blog.csdn.net/qq_37756660/article/details/133862889




