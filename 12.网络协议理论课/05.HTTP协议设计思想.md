# 05.HTTP协议设计思想
#### 目录介绍
- 01.URI和URL设计思想
  - 1.1 如何访问网络资源
  - 1.2 什么是URI
  - 1.3 为何要设计URL
  - 1.4 常用网络协议
  - 1.5 URI和URL设计思想
  - 1.6 HTTP之URL
  - 1.7 URL注意事项
- 02.理解HTTP超文本协议
  - 2.1 HTTP协议介绍
  - 2.2 HTTP在OSI中设计
  - 2.3 什么叫超文本
  - 2.4 什么叫做无状态
  - 2.5 什么叫做无连接
  - 2.6 HTTP协议特点
- 03.HTTP请求与响应
  - 3.1 理解请求和响应
  - 3.2 请求包的设计
  - 3.3 响应包的设计
  - 3.4 报文空行设计
  - 3.5 看一个完整案例
- 04.HTTP一些场景
  - 4.1 如何统计消息长度
- 05.HTTP各个版本
  - 5.1 Http1.0版本
  - 5.2 HTTP1.1版本
  - 5.3 Http2.0版本


## 01.URI和URL设计思想
### 1.1 如何访问网络资源

### 1.2 什么是URI

URI全称是Uniform Resource Identifier，也就是统一资源标识符，它是一种采用特定的语法标识一个资源的字符串表示。

URI所标识的资源可能是服务器上的一个文件，也可能是一个邮件地址、图书、主机名等。简单记为：URI是标识一个资源的字符串(这里先不必纠结标识的目标资源到底是什么，因为使用者一般不会见到资源的实体)，从服务器接收到的只是资源的一种字节表示(二进制序列，从网络流中读取)。

通用URI的格式如下：

```html
scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]
```

如下所示

![image](https://upload-images.jianshu.io/upload_images/4432347-6fd649b48c248f08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

URI一般由三部组成

1. ①访问资源的命名机制
2. ②存放资源的主机名
3. ③资源自身的名称，由路径表示，着重强调于资源。

### 1.3 为何要设计URL

URL全称是Uniform Resource Location，也就是统一资源位置。

1. 实际上，URL就是一种特殊的URI，它除了标识一个资源，还会为资源提供一个特定的网络位置，客户端可以通过它来获取URL对应的资源。 
2. URL所表示的网络资源位置通常包括用于访问服务器的协议(如http、ftp等)、服务器的主机名或者IP地址、以及资源文件在该服务器上的路径。
3. 典型的URL例如http://localhost/myProject/index.html，它指示本地服务器的myProject目录下有一个名为index.html的文档，这个文档可以通过http协议访问(实际上，URL不一定是指服务器中的真实的物理路径，因为我们一般在服务器中部署应用，如Servlet应用，URL访问的很可能是应用的接口，至于最终映射到什么资源可以由应用自身决定)。

URL（Uniform Resource Locator，统一资源定位符）的格式。通常而言，我们所熟悉的 URL 的常见定义格式为：

```text
scheme://host[:port#]/path/.../[;url-params][?query-string][#anchor]
    > scheme //有我们很熟悉的http、https、ftp以及著名的ed2k，迅雷的thunder等。
    > host   //HTTP服务器的IP地址或者域名
    > port#  //HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如tomcat的默认端口是8080 http://localhost:8080/
    > path   //访问资源的路径
    > url-params  //所带参数 
    > query-string    //发送给http服务器的数据
    > anchor //锚点定位
```

格式属性介绍

- protocol：URL中的协议(protocol)是相应于URI中的模式(schema)的另一个叫法。URL中，协议部分可以是file、ftp、http、https、magnet、telnet或者其他定制协议字符串(但是不包括urn)。
- userInfo：URL中的用户信息(userInfo)是服务器的登录信息，这部分信息是可选的。如果这部分信息存在，一般会包含一个用户名，极少情况下会包含一个口令。实际上URL携带用户信息是不安全的。
- port：URL中的端口号(port)是指服务器中应用的运行端口，默认端口为80，此部分信息是可选的(也就如果不指定端口号就使用默认端口80)。
- path：URL中的路径(path)用于表示服务器上的一个特定的目录(其实说一个特定的文件也可以)，这个特定的目录不一定是物理目录，也有可能是逻辑目录。这一点很容易说明，一般不可能把服务器上面的目录直接公开让所有人访问，服务器上面跑的一般是Web(Java的话一般是Servlet)应用，路径指向的实际数据来源甚至很大可能是在其他服务器上的MySQL中的查询结果。
- query：查询参数(query)一般是一个字符串，它表示URL中向服务器提供的附加参数，一般只使用在http协议的URL中，其中包含了表单数据，来源于用户的输入，表示形式是key1=value1&key2=value2&keyn=valuen。
- fragment：片段(fragment)表示远程服务器资源的某个特定的部分。假如服务器资源是一个HTML文档，此片段标识符将制定为该HTML文档的一个锚(Anchor)。如果远程资源是一个XML文档，那么这个片段标识符是一个XPointer。

URL一般由三部组成

- ①协议(或称为服务方式)
- ②存有该资源的主机IP地址(有时也包括端口号)
- ③主机资源的具体地址。如目录和文件名等。


### 1.4 常用网络协议

URI当前的常用模式包括：

- data：链接中直接包含经过BASE64编码的数据。
- file：本地磁盘上的文件。
- ftp：FTP服务器。
- http：使用超文本传输协议。
- mailto：电子邮件的地址。
- magnet：可以通过对等网络(端对端P2P，如BitTorrent)下载的资源。
- telnet：基于Telnet的服务的连接。
- urn：统一资源名(Uniform Resource Name)。

URI （Uniform Resource Identifier，统一资源标识符）。

URI 属于 URL 更高层次的抽象，一种字符串文本标准。就是说，URI 属于父类，而 URL 属于 URI 的子类。URL 是 URI 的一个子集。

```text
ftp://ftp.is.co.za/rfc/rfc1808.txt (URL)
http://www.ietf.org/rfc/rfc2396.txt (URL)
ldap://[2001:db8::7]/c=GB?objectClass?one (URL)
mailto:John.Doe@example.com (URL)
news:comp.infosystems.www.servers.unix (URL)
tel:+1-816-555-1212
telnet://192.0.2.16:80/ (URL)
urn:oasis:names:specification:docbook:dtd:xml:4.1.2
```

### 1.5 URI和URL设计思想

URI（Uniform Resource Identifier）和URL（Uniform Resource Locator）是用于标识和定位网络资源的概念。它们有一些设计思想：

1. 统一性：URI和URL的设计思想之一是提供一种统一的标识和定位机制，使得不同类型的资源都可以通过唯一的标识符进行访问。无论是网页、图片、视频还是其他类型的资源，都可以使用URI或URL进行标识和定位。 
2. 唯一性：URI和URL的设计思想是确保每个资源都有一个唯一的标识符。这样可以避免冲突和混淆，使得每个资源都可以被独立地访问和引用。 
3. 可读性：URI和URL的设计思想也考虑了可读性。它们通常使用人类可理解的字符串来表示资源的标识和定位，使得用户能够更容易地理解和记忆资源的位置。 
4. 层次性：URL的设计思想之一是支持层次结构。URL可以包含多个部分，如协议、域名、路径等，这些部分按照层次结构的方式组织，使得资源的位置可以更具体地表示。 
5. 可扩展性：URI和URL的设计思想也考虑了可扩展性。它们允许通过添加额外的参数、查询字符串或片段标识符来扩展资源的定位和访问方式，以满足不同的需求。


### 1.6 HTTP之URL

HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息

URL，全称是UniformResourceLocator，中文叫统一资源定位符，是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：

http://www.yc.cn:8080/news/index.php?boardID=32&ID=24618&page=1#name

从上面的URL可以看出，一个完整的URL包括以下几部分：

1. 协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符
2. 域名部分：该URL的域名部分为“www.yc.cn”。一个URL中，也可以使用IP地址作为域名使用
3. 端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口 
4. 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” 
5. 文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名 
6. 锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分 
7. 参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。

### 1.7 URL注意事项

URL 只能使用 ASCII 字符集来通过因特网进行发送。由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。

此时就需要对URL进行转义：将需要转码的字符转为16进制，然后从右到左，取4位（不足4位直接处理），每2位做一位，前面加上%，编码成 %XY 格式。

```text
实际输入：https://www.hao123.com/
服务器接收到：https%3A%2F%2Fwww.hao123.com%2F
```


## 02.理解HTTP超文本协议
### 2.1 HTTP协议介绍

**HTTP协议又叫做超文本传输协议，是一种无状态，无连接，以请求-响应方式运行的协议**。

也可以理解为：HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。

### 2.2 HTTP在OSI中设计

HTTP协议属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议，在数据链路层使用MAC地址。

1. TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。
2. IP协议主要解决网络路由和寻址问题。 
3. MAC地址主要解决相邻两台主机之间的寻址传输问题。

### 2.3 什么叫超文本

HTTP 传输的内容是「超文本」。超文本，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。

HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。

### 2.4 什么叫做无状态

**出现HTTP无状态的场景说明**

无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送想要的数据过来，但是发送完，不会记录任何信息，也就是说协议对于发送过的请求或响应都不做持久化处理。

HTTP的无状态是指会话的无状态，什么是会话？会话是由一组请求和响应组成的，围绕一件相关事情的请求和响应，这些不同的请求和响应之间是需要进行数据传递的，但HTTP是无状态指的是本次请求和响应，与下一次的请求和响应是没有关系的，不会发生数据传递。 

**HTTP 协议无状态特性的优点和缺点**：

1. 优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用
2. 缺点在于每次请求会传输大量重复的内容信息

**随着 Web 的不断发展，因无状态而导致业务处理变得棘手的情况增多**

1. 比如客户在购物平台购物场景下，会有这样的场景，登录，下单，购物，客户想要购物，需要登录后才能进行处理，单独靠HTTP是无法完成的。
2. 发起登录的HTTP请求成功登录后，不跟踪客户的登录状态，不对后续购物的请求，进行用户登录数据信息传递，是无法满足业务逻辑的，那么该如何处理呢？

**Cookie解决无状态困境**

1. 每个请求之间都是独立的，对于之前的请求事务没有记忆的能力。所以就出现了像Cookie这种，用来保存一些状态的东西。
2. Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。


### 2.5 什么叫做无连接

**为什么HTTP要设计无连接，它的意图是什么**？

无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，就断开连接。采用这种方式可以节省传输时间。这样主要是为了缓解服务器的压力，减小连接对服务器资源的占用。

**HTTP设计无连接后期遇到的挑战**

早期这么做的原因是 HTTP 协议产生于互联网，因此服务器需要处理同时面向全世界数十万、上百万客户端的网页访问，但每个客户端（即浏览器）与服务器之间交换数据的间歇性较大（即传输具有突发性、瞬时性），并且网页浏览的联想性、发散性导致两次传送的数据关联性很低，大部分通道实际上会很空闲、无端占用资源。

因此 HTTP 的设计者有意利用这种特点将协议设计为请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端。

随着时间的推移，网页变得越来越复杂，里面可能嵌入了很多图片，这时候每次访问图片都需要建立一次 TCP 连接就显得很低效。

**如何解决HTTP无连接遇到的效率低问题**

目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。

1. Keep-Alive 被提出用来解决这效率低的问题：启用Keep-Alive模式肯定更高效，性能更高。因为避免了建立/释放连接的开销。
2. 如何启用Keep-Alive：服务器在响应客户端请求时，会在响应头中包含Connection: keep-alive字段，以指示服务器愿意保持连接。Keep-Alive是HTTP协议的默认行为。

### 2.6 HTTP协议特点

HTTP（Hypertext Transfer Protocol）是一种用于在Web上传输数据的应用层协议。它具有以下特点：

1. 简单易用：HTTP的设计简单明了，易于理解和使用。它使用简单的请求-响应模型，客户端发送请求，服务器返回响应，使得开发和使用HTTP变得相对简单。
2. 无连接：HTTP是一种无连接协议，即每个请求-响应对都是独立的，服务器不会保留客户端的状态信息。这意味着每个请求都需要携带所有必要的信息，而服务器也不会在多个请求之间保持状态。
3. 无状态：HTTP是一种无状态协议，服务器不会记住之前的请求和响应。每个请求都是独立的，服务器无法识别请求是否来自同一客户端。
4. 支持灵活的数据格式：HTTP支持多种数据格式，最常见的是HTML、XML和JSON。这使得HTTP成为传输和交换各种类型数据的通用协议。
5. 可扩展性：HTTP是一个可扩展的协议，通过使用头部字段和方法，可以定义和传递各种自定义的元数据和操作。这使得HTTP能够适应不同的应用需求，并支持各种功能扩展。
6. 基于请求-响应模型：HTTP使用请求-响应模型，客户端发送请求，服务器返回响应。请求包括方法（如GET、POST）、URL、头部字段和可选的请求体，而响应包括状态码、头部字段和响应体。
7. 支持缓存：HTTP支持缓存机制，可以在客户端或代理服务器上缓存响应，以减少重复请求和提高性能。通过使用适当的缓存策略，可以减少网络传输和服务器负载。

## 03.HTTP请求与响应
### 3.1 理解请求和响应

什么是Http报文？它是HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的元信息开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文都是在客户端、服务器和代理之间流动。

HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。

HTTP有两类报文：请求报文(客户端)和响应报文(服务端)。

HTTP报文的流动方向：一次HTTP请求，HTTP报文会从“客户端”流到“代理”再流到“服务器”，在服务器工作完成之后，报文又会从“服务器”流到“代理”再流到“客户端”。



### 3.2 请求包的设计

**客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成**。

请求报文动作，它会向Web服务器请求一个动作。请求报文结构格式：

```text
请求行： <method> <request-URL> <version>
头部：   <headers>
主体：   <entity-body>
```

1. 什么是请求行：所有的HTTP请求报文都以一个请求行作为开始。请求报文的起始行说明了要做些什么。该行包含了一个方法和一个请求的URL，还包含HTTP 的版本。
2. 请求头部：请求头部是只在请求报文中有意义的头部。用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力。
3. 请求主体：可以添加任意的其他数据。

请求报文结构示意图：

![image](http://upload-images.jianshu.io/upload_images/4432347-bda477f9cbacd056.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

例子：请求了就会收到响应包(如果对面存在HTTP服务器)

```
//下面是POST请求
POST /meme.php/home/user/login HTTP/1.1
Host: 114.215.86.90
Cache-Control: no-cache
Postman-Token: bd243d6b-da03-902f-0a2c-8e9377f6f6ed
Content-Type: application/x-www-form-urlencoded

tel=13637829200&password=123456
```

1. 第一部分：请求行，用来说明请求类型，要访问的资源以及所使用的HTTP版本。
2. 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。
3. 第三部分：空行，请求头部后面的空行是必须的。
4. 第四部分：请求数据也叫主体，可以添加任意的其他数据。

常见的请求头部有哪些？

- `User-Agent`：产生请求的浏览器类型。
- `Accept`：客户端可识别的响应内容类型列表;
- `Accept-Language`：客户端可接受的自然语言;
- `Accept-Encoding`：客户端可接受的编码压缩格式;
- `Host`：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机;
- `Connection`：连接方式(close 或 `keep-alive`);
- `Cookie`：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;



### 3.3 响应包的设计

**响应报文动作，它会将请求的结果返回给客户端。响应报文结构格式：状态行、消息报头、空行和响应正文**。

```text
状态行：  <version> <status> <reason-phrase>
响应头部：    <headers>
响应主体：    <entity-body>
```

1. 什么是状态行：所有的HTTP响应报文都以一个状态行作为开始。响应报文的起始行说明发生了什么。该行包含了响应报文使用的HTTP版本、数字状态码、原因短语。
2. 响应头部：响应头部为客户端提供了一些额外信息，比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令。
3. 响应主体：服务器返回给客户端的文本信息。

响应报文结构示意图：

![image](http://upload-images.jianshu.io/upload_images/4432347-ec42b03e531a08dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

例子：

```text
HTTP/1.1 200 OK
Date: Sat, 02 Jan 2016 13:20:55 GMT
Server: Apache/2.4.6 (CentOS) PHP/5.6.14
X-Powered-By: PHP/5.6.14
Content-Length: 78
Keep-Alive: timeout=5, max=100    Connection: Keep-Alive
Content-Type: application/json; charset=utf-8

{"status":202,"info":"\u6b64\u7528\u6237\u4e0d\u5b58\u5728\uff01","data":null}
```

1. 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）
2. 第二部分：消息报头，用来说明客户端要使用的一些附加信息。
3. 第三部分：空行，消息报头后面的空行是必须的。
4. 第四部分：响应正文，服务器返回给客户端的文本信息。

常见的响应头部参数

- `Allow`	服务器支持哪些请求方法（如GET、POST等）。
- `Content-Encoding`	文档的编码（Encode）方法。
- `Content-Length`	表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。
- `Content-Type`	表示后面的文档属于什么MIME类型。
- `Server`	服务器名字。
- `Set-Cookie`	设置和页面关联的Cookie。
- `ETag`：被请求变量的实体值。ETag是一个可以与Web资源关联的记号（MD5值）。
- `Cache-Control`：这个字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。

### 3.4 报文空行设计

为什么有了 Content-Length 字段防止粘包还需要空行呢？

个人理解是，如果报文的数据部分为空（HTTP/HTTPS GET 方法的数据部分就为空）那么头部中的 Content-Length 字段将忽略不写，这样接收方将无法通过这个字段读取指定长度数据，也就无法避免粘包现象！！通过预留空行的方式可以解决这个特殊情况！

HTTP 协议并没有规定报头部分的键值对有多少个，使用空行就相当于是报文的结束标记或报文和正文之间的分隔符（连续2个\r\n代表报头结束）

HTTP 在传输层依赖 TCP 协议，TCP 是面向字节流的。如果没有这个空行，就会出现”粘包问题“

### 3.5 看一个完整案例

请求接口如下所示：https://www.wanandroid.com/friend/json

General
- Request URL: https://www.wanandroid.com/friend/json
- Request Method: GET
- Status Code: 200 OK
- Remote Address: 47.104.74.169:443
- Referrer Policy: no-referrer-when-downgrade

Response Header

- HTTP/1.1 200 OK
- Server: Apache-Coyote/1.1
- Cache-Control: private
- Expires: Thu, 01 Jan 1970 08:00:00 CST
- Content-Type: application/json;charset=UTF-8
- Transfer-Encoding: chunked
- Date: Thu, 10 Sep 2020 01:05:47 GMT

Request Header

- Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
- Accept-Encoding: gzip, deflate, br
- Accept-Language: zh-CN,zh;q=0.9
- Cache-Control: no-cache
- Connection: keep-alive
- Cookie: JSESSIONID=5D6302E64E9734210FA231A6FAF5799E; Hm_lvt_90501e13a75bb5eb3d067166e8d2cad8=1598920692,1599007288,1599094016,1599629553; Hm_lpvt_90501e13a75bb5eb3d067166e8d2cad8=1599699419
- Host: www.wanandroid.com
- Pragma: no-cache
- Sec-Fetch-Dest: document
- Sec-Fetch-Mode: navigate
- Sec-Fetch-Site: none
- Upgrade-Insecure-Requests: 1
- User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36

Response返回body

- 这里省略

看截图如下

![image](https://img-blog.csdnimg.cn/20200910095754628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NzAwMjc1,size_16,color_FFFFFF,t_70#pic_center)

## 04.HTTP一些场景

### 4.1 如何统计消息长度

**Keep-Alive方式下如何判断消息内容/长度的大小**

Keep-Alive模式，客户端如何判断请求所得到的响应数据已经接收完成（或者说如何知道服务器已经发生完了数据）？我们已经知道了，Keep-Alive模式发送玩数据HTTP服务器不会自动断开连接，所有不能再使用返回EOF（-1）来判断（当然你一定要这样使用也没有办法，可以想象那效率是何等的低）！下面我介绍两种来判断方法。

1. 使用消息首部字段Content-Length：表示实体内容长度，客户端（服务器）可以根据这个值来判断数据是否接收完成。但是如果消息中没有Content-Length，那该如何来判断呢？
2. 使用消息首部字段Transfer-Encoding：如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用Transfer-Encoding：chunk模式来传输数据了。

**使用消息首部字段Transfer-Encoding统计长度**

1. 场景：如果要一边产生数据，一边发给客户端，服务器就需要使用"Transfer-Encoding: chunked"这样的方式来代替Content-Length。
2. chunk编码将数据分成一块一块的发生。Chunked编码将使用若干个Chunk串连而成，由一个标明长度为0 的chunk标示结束。每个Chunk分为头部和正文两部分，头部内容指定正文的字符总数（十六进制的数字 ）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用回车换行(CRLF) 隔开。在最后一个长度为0的Chunk中的内容是称为footer的内容，是一些附加的Header信息（通常可以直接忽略）。


## 05.HTTP各个版本
### 5.1 Http1.0版本

HTTP是HyperText Transfer Protocol(超文本传输协议)的英文缩写。HTTP可以通过传输层的TCP协议在客户端和服务器之间传输数据。

HTTP协议主要用于Web浏览器和 Web服务器之间的数据交换。我们在使用IE或Firefox浏览网页或下载Web资源时，通过在地址栏中输入，开头的4个字母http就相当于通知浏览 器使用HTTP协议来和host所确定的服务器进行通讯。

### 5.2 HTTP1.1版本

HTTP1.0默认使用短连接，HTTP1.1开始默认使用长连接

HTTP1.1增加更多的请求头和响应头来改进和扩充HTTP1.0的功能，比如身份认证、状态管理和Cache缓存等

现在更多是使用Http1.1

### 5.3 Http2.0版本

Http2.0相对于Http1.x来说提升是巨大的，主要有以下几点：

1. 二进制格式:http1.x是文本协议，而http2.0是二进制以帧为基本单位，是一个二进制协议，一帧中除了包含数据外同时还包含该帧的标识：StreamIdentifier，即标识了该帧属于哪个request,使得网络传输变得十分灵活。多路复用:一个很大的改进，原先http1.x一个连接一个请求的情况有比较大的局限性，也引发了很多问题，如建立多个连接的消耗以及效率问题。
2. http1.x为了解决效率问题，可能会尽量多的发起并发的请求去加载资源，然而浏览器对于同一域名下的并发请求有限制，而优化的手段一般是将请求的资源放到不同的域名下来突破这种限制。而http2.0支持的多路复用可以很好的解决这个问题，多个请求共用一个TCP连接，多个请求可以同时在这个TCP连接上并发，一个是解决了建立多个TCP连接的消耗问题，一个也解决了效率的问题。

那么是什么原理支撑多个请求可以在一个TCP连接上并发呢？

基本原理就是上面的二进制分帧，因为每一帧都有一个身份标识，所以多个请求的不同帧可以并发的无序发送出去，在服务端会根据每一帧的身份标识，将其整理到对应的request中。

header头部压缩:主要是通过压缩header来减少请求的大小，减少流量消耗，提高效率。因为之前存在一个问题是，每次请求都要带上header，而这个header中的数据通常是一层不变的。


