# 06.传输协议TCP和UDP
#### 目录介绍
- 01.传输协议场景
  - 1.1 应用TCP的场景
  - 1.2 应用UDP的场景
  - 1.3 一些有争议场景
  - 1.4 TCP发送案例分析
  - 1.5 UPD发送案例分析
- 02.TCP基础概念
  - 2.1 TCP的特点
  - 2.2 TCP对应的协议
  - 2.3 一些常见概念
  - 2.4 TCP报文结构
  - 2.5 报文重点概念
  - 2.6 TCP连接最大值
- 03.TCP靠谱协议
  - 3.1 如何建立连接
  - 3.2 三次握手连接
  - 3.3 四次挥手断开
  - 3.4 如何保证可靠
  - 3.5 如何保证顺序
  - 3.6 如何避免丢包
  - 3.7 如何连接维护
  - 3.8 如何控制流量
  - 3.9 如何避免拥塞
  - 3.10 停止等待操作
- 04.UDP基础概念
  - 4.1 什么是UDP
  - 4.2 UDP对应的协议
  - 4.3 UDP的特点
  - 4.4 UDP包数据
  - 4.5 一些常见概念
  - 4.6 UDP也能握手吗
- 05.UDP不可靠协议
  - 5.1 为何无连接
  - 5.2 如何限制大小
  - 5.3 丢包怎么办
- 06.TCP和UDP实践
  - 6.1 TCP实践案例
  - 6.2 UDP实践案例


## 01.传输协议场景
### 1.1 应用TCP的场景

1. 网络通信：TCP广泛用于客户端和服务器之间的通信，例如网页浏览、电子邮件传输、文件传输等。它提供可靠的数据传输，确保数据的完整性和顺序性。
2. 文件传输：TCP协议可用于大文件的可靠传输，例如FTP（文件传输协议）和TFTP（简单文件传输协议）等。
3. 数据库访问：当客户端需要与数据库服务器进行通信时，TCP协议通常用于建立可靠的连接，并传输查询和结果数据。
4. 实时流媒体：TCP协议也可用于实时流媒体应用，如音频和视频流的传输。虽然UDP更常用于实时应用，但TCP可以提供更可靠的传输，适用于某些特定的流媒体场景。

### 1.2 应用UDP的场景

1. 实时通信：UDP适用于实时通信应用，如语音通话、视频聊天和实时游戏。由于UDP不需要建立连接和维护状态，它具有较低的延迟和较小的开销，适合快速传输实时数据。
2. 广播和多播：UDP支持广播和多播功能，可以将数据报发送给多个接收者。这在实时流媒体、在线直播和网络广播等场景中非常有用。
3. DNS（域名系统）：UDP常用于DNS查询，用于将域名解析为IP地址。由于DNS查询通常是短暂的、小数据量的请求，UDP的低延迟和较小的开销使其成为DNS协议的理想选择。

### 1.3 一些有争议场景

**1.现在直播比较火，那直播到底使用TCP还是UDP呢？这个看具体场景**

直播协议多使用 RTMP，而这个 RTMP 协议也是基于 TCP 的。TCP 的严格顺序传输要保证前一个收到了，下一个才能确认，如果前一个收不到，下一个就算包已经收到了，在缓存里面，也需要等着。

对于直播来讲，这显然是不合适的，因为老的视频帧丢了其实也就丢了，就算再传过来用户也不在意了，他们要看新的了，如果老是没来就等着，卡顿了，那就会丢失客户，所以直播，实时性比较比较重要，宁可丢包，也不要卡顿的。

另外，对于丢包，其实对于视频播放来讲，有的包可以丢，有的包不能丢，因为视频的连续帧里面，有的帧重要，有的不重要，如果必须要丢包，隔几个帧丢一个，其实看视频的人不会感知，但是如果连续丢帧，就会感知了，因而在网络不好的情况下，应用希望选择性的丢帧。

还有就是当网络不好的时候，TCP 协议会主动降低发送速度，这对本来当时就卡的看视频来讲是要命的，应该应用层马上重传，而不是主动让步。因而，很多直播应用，都基于 UDP 实现了自己的视频传输协议。

### 1.4 TCP发送案例分析


### 1.5 UPD发送案例分析


## 02.TCP基础概念

### 2.1 TCP的特点

具备的特点

- TCP是面向连接的传输层协议。
- TCP连接是点对点的（套接字--IP:Port到套接字）。
- TCP提供可靠交付的服务。
- TCP提供全双工通信。
- 面向字节流。

### 2.2 TCP对应的协议

**TCP对应的协议**

1. FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。
2. Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。
3. SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。
4. POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。 
5. HTTP协议：是从Web服务器传输超文本到本地浏览器的传送协议。

### 2.3 一些常见概念

`发送缓存和接受缓存`：

用来临时保存双向通信的数据。在发送时，应用程序将数据传送给TCP发送缓存后，就可以做自己的事情，TCP在合适的时候发送数据；在接受数据时，TCP把发送的数据放入缓存，上层应用在合适的时候读取缓存即可。

`滑动窗口`：

TCP的滑动窗口以字节为单位，用3个指针进行表示。当窗口内连续报文段被确认收到后，可以将窗口向前滑动。窗口大小应小于等于缓存区的大小。

`滑动窗口协议`：

只有在接收窗口向前滑动时（与此同时也发送了确认），发送窗口才有可能向前滑动。收发两端的窗口按照以上规律不断地向前滑动，因此这种协议又称为滑动窗口协议。

1. 当发送窗口和接收窗口的大小都等于 1时，就是停止等待协议。
2. 当发送窗口大于1，接收窗口等于1时，就是回退N步协议。
3. 当发送窗口和接收窗口的大小均大于1时，就是选择重发协议。


### 2.4 TCP报文结构

结构图如下所示，摘自网络

![image](https://img-blog.csdnimg.cn/20190409121711902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly96aGFuZ2JveWkuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70)

报文结构如下所示

- 源端口、目的端口：16位长。标识出远端和本地的端口号。
- 序列号：32位长。表明了发送的数据报的顺序，不一定从0开始。
- 确认号：32位长。希望收到的下一个数据报的序列号，表明到序列号`N-1`为止的所有数据已经正确收到。
- TCP协议数据报头长：4位长。表明TCP头中包含多少个32位字。
- 接下来的6位未用。
- ACK：**ACK位置1表明确认号是合法的**。如果ACK为0，那么数据报不包含确认信息，确认字段被省略。
- PSH：表示是带有PUSH标志的数据。接收方因此请求数据报一到便可送往应用程序而不必等到缓冲区装满时才传送。
- RST：用于复位由于主机崩溃或其它原因而出现的错误的连接。还可以用于拒绝非法的数据报或拒绝连接请求。
- SYN：用于建立连接。
- FIN：用于释放连接。
- 窗口大小：16位长。窗口大小字段表示在确认了字节之后还可以发送多少个字节。
- 校验和：16位长。是为了确保高可靠性而设置的。它校验头部、数据和伪TCP头部之和。
- 紧急指针：`URG=1`时才有意义。
- 可选项：长度可变，最长40个字节。
  - MMS
  - SACK：选择确认。
  - 时间戳：计算往返时间；用于处理TCP序号超过`2^32`的情况，又称为防止序号回绕（PAWS）。
- TCP最小长度为20个字节。


### 2.5 报文重点概念

**端口号**

源端口号和目标端口号是不可少的，这一点和UDP是一样的。如果没有这两个端口号。数据就不知道应该发给哪个应用。

**包的序号**

为什么要给包编号呢？当然是为了解决乱序的问题。不编好号怎么确认哪个应该先来，哪个应该后到呢。编号是为了解决乱序问题。既然是社会老司机，做事当然要稳重，一件件来，面临再复杂的情况，也临危不乱。

**确认序号**

确认序号。发出去的包应该有确认，要不然我怎么知道对方有没有收到呢？如果没有收到就应该重新发送，直到送达。这个可以解决不丢包的问题。作为老司机，做事当然要靠谱，答应了就要做到，暂时做不到也要有个回复。

**状态位**

接下来有一些状态位。例如 SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。

**窗口大小**

还有一个重要的就是窗口大小。TCP要做流量控制，通信双方各声明一个窗口，标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。

除了做流量控制以外，TCP还会做拥塞控制，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。

### 2.6 TCP连接最大值

当时读到一篇讨论服务器可以承受多少 TCP 连接（就是 C10k 问题）的文章时，还觉得奇怪，不是端口范围只有 0~65535 吗？为什么还会有几十万上百万连接呢？

这就是没有意识到，连接是四元组（源IP地址、源端口号、目标IP地址和目标端口号），并不是单纯的源端口或者目的端口。那么多个数相乘，这个乘积当然可以远远超过 65535 了。

先不谈论海量级网站的场景，就算我们维护一台 Web 服务器，假如当前有 10 万台客户端连着你，平均每个客户端跟你有 6 个连接（这很常见），那么就是 60 万个连接了，是不是也早就超过 6 万了？

在限定场景下，一个客户端（假设只有一个出口 IP）和一个服务端（假设也只有一个 IP 和一个服务端口），那么确实只能最多发起 6 万多个连接。

## 03.TCP靠谱协议

TCP 是靠谱的协议，但是这不能说明它面临的网络环境好。从IP层面来讲，如果网络状况的确那么差，是没有任何可靠性保证的，而作为IP的上一层TCP也无能为力，唯一能做的就是更加努力，不断重传，通过各种算法保证。

也就是说，对于TCP来讲，IP层你丢不丢包，我管不着，但是我在我的层面上，会努力保证可靠性。

通过对 TCP 头的解析，我们知道要掌握 TCP 协议，重点应该关注以下几个问题：

- 顺序问题 ，稳重不乱；
- 丢包问题，承诺靠谱；
- 连接维护，有始有终；
- 流量控制，把握分寸；
- 拥塞控制，知进知退。

### 3.1 如何建立连接


### 3.2 三次握手连接

一般来说 TCP 连接是标准的 TCP 三次握手完成的：第一次客户端发送 SYN；第二次服务端收到 SYN 后，回复 SYN+ACK；第三次客户端收到 SYN+ACK 后，回复 ACK。

1. 第一次：客户端，发送SNY=1表示此次握手是请求建立连接的，然后seq生成一个客户端的随机数X
2. 第二次：服务端收到客户端数据后，服务端，发送SNY=1,ACK=1表示是回复请求建立连接的，然后ack=客户端的seq+1（这样客户端收到后就能确认是之前想要连接的那个服务端），然后把服务端也生成一个代表自己的随机数seq=Y发给客户端。
3. 第三次：客户端收到服务端数据，客户端回复，ACK=1。seq=客户端随机数+1，ack=服务端随机数+1（这样服务端就知道是刚刚那个客户端了）

![image](https://upload-images.jianshu.io/upload_images/4432347-dcf7d168c55a1ee4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

1. 第一次握手，C端发了个连接请求消息到S端，S端收到后S端就知道自己与C端是可以连接成功的
2. 第二次握手，C端此时并不知道S端是否接收到这个消息，所以S端接收到消息后得应答，C端得到S端的回复后，才能确定自己与S端是可以连接上的。C端只有确定了自己能与S端连接上才能开始发数据。所以两次握手肯定是最基本的。 
3. 那么为什么需要第三次握手呢？假设一下如果没有第三次握手，而是两次握手后我们就认为连接建立，那么会发生什么？

`问题：为什么建立连接需要三次握手？`

**第三次握手是为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误**。具体情况就是：

C端发出去的第一个网络连接请求由于某些原因在网络节点中滞留了，导致延迟，直到连接释放的某个时间点才到达S端，这是一个早已失效的报文，但是此时S端仍然认为这是C端的建立连接请求第一次握手，于是S端回应了C端，第二次握手。

如果只有两次握手，那么到这里，连接就建立了，但是此时C端并没有任何数据要发送，而S端就会傻傻的等待着，造成很大的资源浪费。所以需要第三次握手，只有C端再次回应一下，就可以避免这种情况。

### 3.3 四次挥手断开

![image](https://upload-images.jianshu.io/upload_images/4432347-2e0f20b0eb55a04a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

如图所示：经过上面的建立连接图的解析，这个图应该不难看懂，这里主要有一个问题：为什么比建立连接时多了一次握手？

简单说来是“先关读，后关写”，一共需要四个阶段：服务器读通道关闭->客户机写通道关闭->客户机读通道关闭->服务器写通道关闭。这样就变成了四次握手了。

1. 第一步（客户端发送FIN）：客户端发送一个带有FIN（终止）标志的TCP报文段给服务器，表示客户端不再发送数据。
2. 第二步（服务器发送ACK）：服务器收到客户端的FIN后，发送一个确认ACK（确认）报文段给客户端，表示已收到客户端的终止请求。
3. 第三步（服务器发送FIN）：服务器发送一个带有FIN标志的TCP报文段给客户端，表示服务器也不再发送数据。
4. 第四步（客户端发送ACK）：客户端收到服务器的FIN后，发送一个确认ACK报文段给服务器，表示已收到服务器的终止请求。

`问题：看到这里服务端的ACK(回复客户端)和FIN(终止)消息并不是同时发出的，为何这样？`

先ACK，然后再FIN，这也很好理解，当客户端要求断开连接时，此时服务端可能还有未发送完的数据，所以先ACK，然后等数据发送完再FIN。

由于TCP连接是全双工的，因此每个方向都必须单独关闭。客户端在数据发送完毕后发送一个结束数据段FIN，且服务端也返回确认数据段ACK，此时结束了客户端到服务端的连接；然后客户端接收到服务端发送的FIN，且服务端也收到了ACK之后，自此双方的数据通信完全结束。

`问题：TCP采用四次挥手关闭连接如图所示为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？`

这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。

但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

### 3.4 如何保证可靠

TCP（传输控制协议）通过以下机制来保证可靠传输：

它在面对网络丢包、延迟、拥塞等问题时能够自适应地调整传输行为，以保证数据的可靠传输。

1. 序列号和确认应答：应用数据被分割成 TCP 认为最适合发送的数据块，将每个发送的数据包进行编号，接收方通过发送确认应答（ACK）来确认已接收到的数据，并且接收方对数据包进行排序。
2. 超时重传：TCP使用超时重传机制来处理丢失的数据包。如果发送方在一定时间内未收到确认应答，它会假设数据包已丢失，并重新发送该数据包。
3. 校验和：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4. 滑动窗口：TCP使用滑动窗口机制来控制发送方和接收方之间的数据流量。滑动窗口大小可以根据网络状况进行动态调整，以确保发送方不会发送过多的数据，超出接收方的处理能力。
5. 流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。
6. 拥塞控制：TCP使用拥塞控制机制来避免网络拥塞。它通过动态调整发送速率，根据网络的拥塞程度来控制发送方的数据发送速度，以保持网络的稳定性。
7. 停止等待协议：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。

### 3.5 如何保证顺序

核心的设计思想：TCP通过使用序列号、确认应答和接收窗口等机制，确保数据包按照发送顺序到达接收方，从而保证传输顺序的可靠性。

第一步：设计序列号来确保顺序。TCP为每个发送的数据包分配一个唯一的序列号。这个序列号用于标识数据包的顺序。接收方根据序列号来确定数据包的顺序。

第二步：确认应答方式来确保数据传输可靠。接收方会发送确认应答（ACK）来告知发送方已成功接收到数据。发送方根据接收到的ACK来确认数据包的传输成功。如果发送方未收到确认应答，它会重新发送数据包，以确保数据的可靠传输。

第三步：接收窗口来控制发送和接收数据量。TCP使用接收窗口来控制接收方的数据处理能力。接收窗口的大小表示接收方当前能够接收的数据量。发送方根据接收窗口的大小来控制发送的数据量，确保不会超过接收方的处理能力。接收方可以通过调整接收窗口的大小来告知发送方自己的处理能力。

### 3.6 如何避免丢包

TCP能够有效地避免数据包的丢失。它通过序列号、确认应答、超时重传、滑动窗口和拥塞控制等机制，保证数据的可靠传输，减少丢包的风险。

超时重传：如果发送方在一定时间内未收到确认应答，它会假设数据包已丢失，并重新发送该数据包。通过超时重传机制，TCP能够在数据包丢失时重新发送，以确保数据的可靠性。

### 3.7 如何连接维护


### 3.8 如何控制流量

流量控制指点对点通信量的控制，是端到端正的问题。**流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。这里是通过滑动窗口机制来实现的**。发送方的发送窗口不能超过接收方的接收窗口。TCP的窗口单位是字节，不是报文段。

![image](https://upload-images.jianshu.io/upload_images/4432347-1fd32c380e64cd66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这上图中B一共进行了三次流量控制：第一次将窗口减小到`300`，第二次减小到`100`，最后减小到`0`，这时发送方暂停发送知道B发送一个新的窗口值为止。

如果B发送了一个新的窗口值到A，但是A并没有收到，就会造成死锁。为解决这个问题，TCP为每个链接设置有一个持续计时器。只要TCP收到一个0窗口，就启动计时器。若计时器设置的时间到了，就发送一个探测报文，而接收方在确认的时候会给出一个现在的窗口值。


### 3.9 如何避免拥塞

**防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载**。

拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。

**1.慢开始和拥塞避免**。发送方维持一个拥塞窗口`cwnd`的状态变量。**发送方让自己的发送窗口小于等于拥塞窗口**。

![image](https://upload-images.jianshu.io/upload_images/4432347-7db8780a360a435d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- `慢开始`：**由小到大的逐渐增大拥塞窗口**。首先将cwnd设置为一个最大报文段MMS，在收到一个对新的报文段的确认后，把拥塞窗口增加一个MMS。——指数增长
- `拥塞避免`：当慢开始到门限值（ssthresh）后，使用拥塞避免算法（cwnd每次加1）。当发现网络拥塞后，将cwnd置为1，ssthresh减半，再次执行慢开始。

**2.快重传和快恢复**

`快重传`：**当接收方收到一个失序报文段后就立即发送重复确认而不要等到自己发送数据时捎带确认**。当发送方连续收到三个重复确认时，应立即重传接收方尚未收到的报文段。

`快恢复`：与快重传结合使用。

- 在连续收到三个重复确认时，将慢开始的ssthresh减半，这是为了防止网络拥塞（ ** 接下来并不执行慢开始 ** ）。
- 由于发送方现在认为 *网络很可能没有拥塞*，于是接下来不执行慢开始，而是将cwnd值设置为ssthresh减半后的值，然后执行拥塞避免。

### 3.10 停止等待操作

无差错情况
- 发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。
  - ![image](https://user-gold-cdn.xitu.io/2018/8/16/16541fa8c3816a90?w=514&h=473&f=png&s=9924)

出现差错情况
- 停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 **自动重传请求 ARQ** 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。**连续 ARQ 协议** 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。
  - ![image](https://user-gold-cdn.xitu.io/2018/8/16/16541faefdf249ab?w=953&h=480&f=png&s=19163)

**确认丢失和确认迟到**


**确认丢失**：确认消息在传输过程丢失

![](https://user-gold-cdn.xitu.io/2018/8/16/16541fb6941a7165?w=918&h=461&f=png&s=19841)

当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：

1.丢弃这个重复的M1消息，不向上层交付。

2.向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。

**确认迟到** ：确认消息在传输过程中迟到

![](https://user-gold-cdn.xitu.io/2018/8/16/16541fdd85929e6b?w=899&h=450&f=png&s=23165)

A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：

1.A收到重复的确认后，直接丢弃。[博客](https://github.com/yangchong211/YCBlogs)

2.B收到重复的M1后，也直接丢弃重复的M1。


## 04.UDP基础概念
### 4.1 什么是UDP

* 面向无连接
* 每个数据报的大小在限制在64k内
* 因为是面向无连接，所以是不可靠协议
* 不需要建立连接，速度快

### 4.2 UDP对应的协议

UDP对应的协议：

- DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
- SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
- FTP：简单文件传输协议，该协议在熟知端口69上使用UDP服务。

### 4.3 UDP的特点

第一，沟通简单，不需要一肚子花花肠子（大量的数据结构、处理逻辑、包头字段）。前提是它相信网络世界是美好的，秉承性善论，相信网络通路默认就是很容易送达的，不容易被丢弃的。

第二，轻信他人。它不会建立连接，虽然有端口号，但是监听在这个地方，谁都可以传给他数据，他也可以传给任何人数据，甚至可以同时传给多个人数据。

第三，愣头青，做事不懂权变。不知道什么时候该坚持，什么时候该退让。它不会根据网络的情况进行发包的拥塞控制，无论网络丢包丢成啥样了，它该怎么发还怎么发。

### 4.4 UDP包数据

- 当我发送的 UDP 包到达目标机器后，发现 MAC 地址匹配，于是就取下来，将剩下的包传给处理 IP 层的代码。把 IP 头取下来，发现目标 IP 匹配，接下来呢？这里面的数据包是给谁呢？
- 发送的时候，我知道我发的是一个 UDP 的包，收到的那台机器咋知道的呢？所以在 IP 头里面有个 8 位协议，这里会存放，数据里面到底是 TCP 还是 UDP，当然这里是 UDP。于是，如果我们知道 UDP 头的格式，就能从数据里面，将它解析出来。解析出来以后呢？数据给谁处理呢？
- 处理完传输层的事情，内核的事情基本就干完了，里面的数据应该交给应用程序自己去处理，可是一台机器上跑着这么多的应用程序，应该给谁呢？
- 无论应用程序写的使用 TCP传数据，还是UDP传数据，都要监听一个端口。正是这个端口，用来区分应用程序，要不说端口不能冲突呢。两个应用监听一个端口，到时候包给谁呀？所以，按理说，无论是 TCP 还是 UDP 包头里面应该有端口号，根据端口号，将数据交给相应的应用程序。
  - ![image](https://img-blog.csdnimg.cn/2019040911584931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly96aGFuZ2JveWkuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70)
- 当我们看到 UDP 包头的时候，发现的确有端口号，有源端口号和目标端口号。因为是两端通信嘛，这很好理解。但是你还会发现，UDP 除了端口号，再没有其他的了。


### 4.5 一些常见概念


### 4.6 UDP也能握手吗

UDP本身是一种无连接的协议，不提供内置的握手机制。应用程序可以在UDP通信的开始阶段自行定义握手过程，以确保通信双方能够互相确认彼此的可用性和准备就绪状态。



## 05.UDP不可靠协议
### 5.1 为何无连接


### 5.2 如何限制大小


### 5.3 丢包怎么办




### 04.UDP三大使用场景
- 第一，需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。
  - DHCP 就是基于 UDP 协议的。一般的获取 IP 地址都是内网请求，而且一次获取不到 IP 又没事，过一会儿还有机会。我们讲过PXE可以在启动的时候自动安装操作系统，操作系统镜像的下载使用的 TFTP，这个也是基于UDP协议的。在还没有操作系统的时候，客户端拥有的资源很少，不适合维护一个复杂的状态机，而是因为是内网，一般也没啥问题。
- 第二，不需要一对一沟通，建立连接，而是可以广播的应用。
  - UDP 的不面向连接的功能，可以使得可以承载广播或者多播的协议。DHCP就是一种广播的形式，就是基于 UDP 协议的，而广播包的格式前面说过了。
  - 对于多播，我们在讲 IP地址的时候，讲过一个D类地址，也即组播地址，使用这个地址，可以将包组播给一批机器。当一台机器上的某个进程想监听某个组播地址的时候，需要发送 IGMP 包，所在网络的路由器就能收到这个包，知道有个机器上有个进程在监听这个组播地址。当路由器收到这个组播地址的时候，会将包转发给这台机器，这样就实现了跨路由器的组播。
  - 在后面云中网络部分，有一个协议 VXLAN，也是需要用到组播，也是基于 UDP 协议的。
    -第三，需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩。
  - UDP 简单、处理速度快，不像TCP那样，操这么多的心，各种重传啊，保证顺序啊，前面的不收到，后面的没法处理啊。不然等这些事情做完了，时延早就上去了。而TCP在网络不好出现丢包的时候，拥塞控制策略会主动的退缩，降低发送速度，这就相当于本来环境就差，还自断臂膀，用户本来就卡，这下更卡了
  - 当前很多应用都是要求低时延的，它们可不想用 TCP 如此复杂的机制，而是想根据自己的场景，实现自己的可靠和连接保证。例如，如果应用自己觉得，有的包丢了就丢了，没必要重传了，就可以算了，有的比较重要，则应用自己重传，而不依赖于 TCP。有的前面的包没到，后面的包到了，那就先给客户展示后面的嘛，干嘛非得等到齐了呢？如果网络不好，丢了包，那不能退缩啊，要尽快传啊，速度不能降下来啊，要挤占带宽，抢在客户失去耐心之前到达。
  - 由于 UDP 十分简单，基本啥都没做，也就给了应用“城会玩”的机会。就像在和平年代，每个人应该有独立的思考和行为，应该可靠并且礼让；但是如果在战争年代，往往不太需要过于独立的思考，而需要士兵简单服从命令就可以了。



### 06.看一道面试题
#### 6.1 发微信和看视频
- 微信发送文件，应该是TCP协议，而网络播放视频适合用UDP。
  - UDP适用于对网络通讯质量要求不高、要求网络通讯速度能尽量快的实时性应用；
  - TCP适用于对网络通讯质量有要求的可靠性应用。
  - 播放视频区分关键帧和普通帧，虽然UDP会丢帧但如果只是丢普通帧损失并不大，取而代之的是高速率和实时性。


#### 6.2 面试之TCP和UDP
- 一般面试的时候我问这两个协议的区别，大部分人会回答，TCP 是面向连接的，UDP 是面向无连接的。
- 什么叫面向连接，什么叫无连接呢？在互通之前，面向连接的协议会先建立连接。例如，TCP 会三次握手，而 UDP 不会。为什么要建立连接呢？你 TCP 三次握手，我 UDP 也可以发三个包玩玩，有什么区别吗？
- 所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。
- 例如，TCP 提供可靠交付。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。我们都知道 IP 包是没有任何可靠性保证的，一旦发出去，就像西天取经，走丢了、被妖怪吃了，都只能随它去。但是 TCP 号称能做到那个连接维护的程序做的事情，这个下两节我会详细描述。而UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达。
- 再如，TCP 是面向字节流的。发送的时候发的是一个流，没头没尾。IP 包可不是一个流，而是一个个的 IP 包。之所以变成了流，这也是 TCP 自己的状态维护做的事情。而UDP 继承了 IP 的特性，基于数据报的，一个一个地发，一个一个地收。
- 还有TCP 是可以有拥塞控制的。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。UDP 就不会，应用让我发，我就发，管它洪水滔天。
- 因而TCP 其实是一个有状态服务，通俗地讲就是有脑子的，里面精确地记着发送了没有，接收到没有，发送到哪个了，应该接收哪个了，错一点儿都不行。而 **UDP 则是无状态服务。** 通俗地说是没脑子的，天真无邪的，发出去就发出去了。
- 我们可以这样比喻，如果 MAC 层定义了本地局域网的传输行为，IP 层定义了整个网络端到端的传输行为，这两层基本定义了这样的基因：网络传输是以包为单位的，二层叫帧，网络层叫包，传输层叫段。我们笼统地称为包。包单独传输，自行选路，在不同的设备封装解封装，不保证到达。基于这个基因，生下来的孩子 UDP 完全继承了这些特性，几乎没有自己的思想。




### 10.UDP代码案例
#### 10.1客户端发送数据
- 客户端发送数据
```
/**
 * 端口号
 */
private static final int PORT = 8080;

/*
 * UDP协议发送数据：
 * 1.创建发送端Socket对象
 * 2.创建数据，并把数据打包
 * 3.调用Socket对象发送方法发送数据包
 * 4.释放资源
 */
private void udpSendMessage(String serverAddress) {
    String content = "yang";
    // 创建发送端Socket对象
    try {
        // 创建发送端Socket对象
        DatagramSocket ds = new DatagramSocket();
        // 创建数据，并把数据打包
        byte[] bys = content.getBytes();
        InetAddress byName = InetAddress.getByName(serverAddress);
        DatagramPacket dp = new DatagramPacket(bys, bys.length,byName ,PORT);
        // 调用Socket对象发送方法发送数据包
        ds.send(dp);
        // 释放资源
        ds.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```


#### 10.2服务端接收数据
- 服务端接收数据
```
/*
     * UDP协议接收数据：
     * 1.创建接收端Socket对象
     * 2.创建一个数据包(接收容器)
     * 3.调用Socket对象接收方法接收数据包
     * 4.解析数据包
     * 5.释放资源
     */
private void receive_udp() {
    try {
        // 创建接收端Socket对象
        DatagramSocket ds = new DatagramSocket(PORT);
        // 创建一个数据包(接收容器)
        byte[] bys = new byte[1024];
        DatagramPacket dp = new DatagramPacket(bys, bys.length);
        // 调用Socket对象接收方法接收数据包
        ds.receive(dp);
        // 获取对方的ip
        String ip = dp.getAddress().getHostAddress();
        // 解析数据
        String data = new String(dp.getData(), 0, dp.getLength());
        Message message = new Message();
        message.obj = data;
        message.what = 2;
        handler.sendMessage(message);
        // 关闭数据库
        ds.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```





### 11.传输伪代码
#### 11.1 客户端发送数据
```
/**
 * 端口号
 */
private static final int PORT = 8080;

/**
 * @param serverAddress 要发送到服务端的ip
 * 1.创建socket并指定ip和端口号
 * 2.获取输出流，写数据
 * 3.释放资源
 * 4.Tcp一定要先开接收端
 */
public void send_tcp(String serverAddress) {
    try {
        Socket s = new Socket(serverAddress, PORT);
        //为了发送数据，应该获得socket流中的输出流
        OutputStream out = s.getOutputStream();
        String content = "yang";
        out.write(content.getBytes());
        s.close();
    } catch (UnknownHostException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```


#### 11.2 服务端接收数据
```
/**
 * TCP协议接收数据
 * 1.创建接收端的Socket对象
 * 2.监听客户端接收，返回一个Socket对象
 * 3.获取输入流，读取数据显示在控制台
 * 4.释放资源
 */
public void receive_tcp() {
    try {
        //1.建立连接，监听端口
        ServerSocket ss = new ServerSocket(PORT);
        //2.连接客户端对象
        while (true) {
            //阻塞式方法，只有客户端连接了才会继续往下运行
            Socket accept = ss.accept();
            //获取ip
            String ip = accept.getInetAddress().getHostAddress();
            //3.获取客户端发送过来的数据
            InputStream in = accept.getInputStream();
            //4.开始读取,获取输入信息
            BufferedReader bff = new BufferedReader(new InputStreamReader(in));
            //读取信息
            String line;
            final StringBuilder sb = new StringBuilder();
            while ((line = bff.readLine()) != null) {
                sb.append(line);
            }
            Message message = new Message();
            message.obj = sb.toString();
            handler.sendMessage(message);
            //5.关闭
            //ss.close();
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```




- 实时游戏
  - 游戏有一个特点，就是实时性比较高。快一秒你干掉别人，慢一秒你被别人爆头，所以很多职业玩家会买非常专业的鼠标和键盘，争分夺秒。
  - 因而，实时游戏中客户端和服务端要建立长连接，来保证实时传输。但是游戏玩家很多，服务器却不多。由于维护 TCP 连接需要在内核维护一些数据结构，因而一台机器能够支撑的 TCP 连接数目是有限的，然后 UDP 由于是没有连接的，在异步 IO 机制引入之前，常常是应对海量客户端连接的策略。
  - 另外还是 TCP 的强顺序问题，对战的游戏，对网络的要求很简单，玩家通过客户端发送给服务器鼠标和键盘行走的位置，服务器会处理每个用户发送过来的所有场景，处理完再返回给客户端，客户端解析响应，渲染最新的场景展示给玩家。
  - 如果出现一个数据包丢失，所有事情都需要停下来等待这个数据包重发。客户端会出现等待接收数据，然而玩家并不关心过期的数据，激战中卡 1 秒，等能动了都已经死了。
  - 游戏对实时要求较为严格的情况下，采用自定义的可靠 UDP 协议，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。










