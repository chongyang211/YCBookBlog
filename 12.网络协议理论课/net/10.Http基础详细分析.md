#### 目录介绍



### 08.Http代理介绍
#### 8.1 什么 HTTP 代理？
- 说到 HTTP 代理
    - 作为客户端开发，最熟悉的就是使用 Fiddler、Charles 等工具进行抓包时，需要在手机上挂个代理，来方便我们排查一些网络问题，这只是代理众多使用场景中的一个。
    - 实际上，HTTP 代理（Web代理）是一种存在于网络中间的实体，可以提供各种功能。如果没有 HTTP 代理，客户终端就要直接与终端服务器进行交互。而有了 HTTP 代理后，客户终端就可以与代理通信，然后由代理代表客户端与服务器进行交互。
- 代理服务
    - 就是代理客户端完成事务处理的中间人，它接管客户端的事务，代替客户端与服务端交互。
    - 代理服务是一个抽象的中间实体，可以存在网络的各个中间点，浏览器、路由器、代理服务器、Web 服务器的反向代理等，


#### 8.2 HTTP 代理的分类
- 从最熟悉的抓包工具说起
    - Fiddler、Charles 这种抓包工具，封装的都非常好，哪怕我们完全不理解 HTTP 代理的细节，简单配置就可以使用。
- 在使用过程中，你会发现两种场景：
    - 对于 HTTP 协议请求，可以直接显示请求/响应报文的细节
    - 对于 HTTPS ，如果没有导入证书，请求依然可以发送至服务器，并且也可以正常返回数据，但是不会显示报文细节。
- 在没有导入证书的情况下，HTTPS 请求我们无法获知细节，但是并不影响我们的请求和响应。
- 这个两种不同的表现，也对应了两种不同的 HTTP 代理：
    - 普通代理。基于修订后的 RFC 2616 在 HTTP/1.1 中被定义。这种代理扮演的是「中间人」的角色。对客户端来说，它是服务端，而对真正的服务端来说，它又是客户端，它就是负责在两端之间传递 HTTP 报文。
    - 隧道代理。这种一种基于 TCP 协议的隧道传输代理，它通过 HTTP 协议的 CONNECT 方法完成通信，以 HTTP 的方式，实现任意基于 TCP 的应用层协议代理。



#### 8.3 普通代理
- 普通代理
    - 它是网络中的中间实体，位于客户端和服务端之间，扮演「中间人」的角色，在两端之间来回传递报文。
    - 这个「中间人」左手牵着客户端，右手牵着服务端，在收到客户端发送的请求报文时，需要正确的处理请求和连接状态，同时向服务器发送新的请求，在收到响应后，将响应结果包装成一个响应体返回给客户端。
- 在普通代理的流程中，代理两端都是有可能察觉不到「中间人」的存在。
    - 举个例子，我们要访问 A 网站，实际上我们是向代理服务器发送请求，而代理服务器又再向 A 网站发起请求，最终将响应体通过代理服务器，返回给我们。在我们的角度，我们正常的向一个网站服务器发起请求，并且对方也返回给我们正确的数据，在这个过程中，我作为客户端，会认为代理服务器就是 A 网站的服务器，而 A 网站的服务器，又认为代理服务器是一个真实的用户。

这里说到，代理服务器作为「中间人」是可以隐藏自己的存在，但是如果我们作为一个“守规矩”的代理服务器，想要将客户端的 IP 传递给服务端，可以通过 X-Forwarded-IP 这个自定义的 Header，来告诉服务端真正的客户端 IP 地址。

HTTP 协议作为一种松散的协议，服务器在接收到 X-Forwarded-IP 这个请求头时，是无法验证其真伪的。它可能是代理服务器伪造的，也可能是真实的。所以服务端从 HTTP 头部获取 IP 时，就需要格外小心。

普通代理很好理解，但是它也有缺陷，它只适用于 HTTP 协议。

在普通代理模式下，所有请求响应的数据，对于代理这个「中间人」来说，都是透明并且可以任意操作，这就会带来各种数据安全的隐患。

说到网络数据安全，首先想到的就是 HTTPS，但是 HTTPS 这种证书认证的机制，又是中间人劫持的克星。

严格上来说，HTTPS 下不存在中间人攻击，除非是人为的犯错了，没有对证书严格校验，或者证书被泄露。

在普通的 HTTPS 请求中，服务端不验证客户端的证书，中间人可以作为客户端与服务端完成 TLS 握手。

但是由于代理中间人没有证书密钥，也就无法伪造服务端和客户端简历的 TLS 连接，这会导致请求失败。

这个场景，对标到抓包工具的工作流程中，你会发现，如果想用 Charles（或Fiddler） 抓 HTTPS 的网络数据包，就需要在手机上安装一个 Charles 的 CA 证书，让手机设备信任此证书，才可以完成抓包，此时走的就是普通代理的模式。

那换个角度，假如在手机上没有安装 Charles 提供的证书，也并没有影响到请求和响应，Charles 只是无法解密 HTTPS 数据，这是如何做到的呢？



#### 8.4 隧道代理

隧道代理，又称为 Web 隧道（Web tunnel），这种方式可以通过 HTTP 连接发送非 HTTP 流量，这样可以在 HTTP 上捎带其他协议的数据。

隧道代理是利用 HTTP 的 CONNECT 方法建立起来的。CONNECT 方法，最初并不是 HTTP/1.1 的核心规范，但却是一种得到广泛使用的扩展，它在 2014 年发布的 HTTP/1.1 修订版中，才对 CONNECT 及隧道代理有了清晰的描述。

HTTP 隧道代理的工作流程是什么样的？

一次普通的 HTTP 请求，Header 部分以连续的两组 CRLF（\r\n）作为结束标记，如果后面还有内容，就是 Content 部分的内容，也称为请求/响应体（Content），如果存在 Content 内容，就需要在 Header 中增加 Content-Length 来标记 Content 部分的长度。接收方（服务端）会根据这个长度来读取数据。

CONNECT 报文的请求，是没有 Content 部分的，只有 Request-Line 和 Header，他们仅供代理服务器使用，并不会传递给终端服务器。请求的 Header 部分一旦结束（两组连续的 CRLF），后面的所有数据，都被视为应该转发给终端服务器的数据，代理需要把他们无脑的直接转发，并且不限制长度，直到从客户端的 TCP 读通道关闭。

CONNECT 的响应报文，在代理服务器和终端服务器建立连接后，可以向客户端返回一个 200 Connect established 的状态码，以此表示和终端服务器的连接，建立成功。这个 200 Connect established 的 Header 部分一旦结束（两组连续的 CRLF），后面所有的数据均为远端服务器返回的数据，同理，代理服务器会直接转发终端服务器的数据给客户端，直到终端服务器的 TCP 读通道关闭。


了解清楚 HTTP 隧道的工作流程之后，就知道 CONNECT 方法请求隧道网管创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务端之间的后续数据，进行无脑的盲转发。

通过隧道代理，代理服务器不再作为中间人，不再需要改写浏览器的请求，而是把浏览器和终端服务器的数据，原样转发，这样浏览器就可以直接和终端服务器进行 TLS 握手，并传输加密的数据。


#### 8.5 最后总结一下
- HTTP 代理可以分为两类，普通代理和隧道代理。
    - 普通代理作为「中间人」存在，在一次请求中，客户端明文请求代理服务器，在收到请求后，代理服务器又明文去请求终端服务器。在这整个过程中，数据都是明文传输，中间人可以对其中传递的数据进行改写，这就是著名的中间人攻击，可见其有多不安全。
    - 这就引申出了支持 HTTPS 的隧道代理，此时代理服务器就不再作为中间人，无法改写客户端的请求，而仅仅是在建立连接后，将客户端的请求，通过建立好的隧道，无脑的转发给终端服务器。



### 09.Http和Tcp和Socket
- HTTP 、TCP、Socket三者之间的区别是什么？
    - TCP/IP代表传输控制协议/网际协议，指的是一系列协组
    - HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议
    - Socket是TCP/IP网络的API其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议
    - 综上所述：需要IP协议来连接网络;TCP是一种允许我们安全传输数据的机制，使用TCP协议来传输数据的HTTP是Web服务器和客户端使用的特殊协议。HTTP基于TCP协议，但是却可以使用socket去建立一个TCP连接
- HTTP和Socket的区别
    - HTTP是应用层协议；基于TCP协议；使用“请求—响应”方式建立连接，在请求时需要先建立连接且客户端要先发出请求，可见服务器需要等到客户端发送一次请求后才能将数据传回给客户端
    - Socket（套接字）是对TCP/IP协议的封装，是接口而不是协议；创建Socket连接时可以指定传输层协议TCP或UDP；Socket建立连接过程三步骤：服务器监听->客户端请求->连接确认，可见服务器可以直接将数据传送给客户端（HTTP2.0也增加了服务端推送的功能）



### 13.Http持久连接
#### 13.1 最初通信方式
- HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP连接。
    - 以当年的通信情况来说，因为都是些容量很小的文本传输，所以即使这样也没有多大问题。可随着 HTTP 的普及，文档中包含大量图片的情况多了起来。
- 三次握手保证数据准确性
    - 客户端与服务器端要进行通信，TCP协议为了保证通信的准确性，会进行“三次握手”来保证信息传递的准确性，确认完之后才会进行HTTP请求和响应的传输，传输完之后服务器端发出终止信号FIN，断开TCP连接。
- 遇到的问题
    - 针对复杂的页面，这样太频繁会造成资源的开销。
    - 比如，使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。



#### 13.2 解决的方式
- 解决方式
    - 持久化链接
    - 管线化
- 持久化链接
    - 什么是持久化链接
        - 为了解决上述TCP连接的问题，HTTP/1.1想出了持久连接的方法，持久连接就是只要任意一端没有明确提出断开连接，则保持TCP连接状态。
        - ![image](https://upload-images.jianshu.io/upload_images/4432347-e5b5281db50263fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    - 持久连接的好处：
        - 减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。
        - 减少开销的那部分时间，使HTTP请求和响应能够更早的结束，因此Web页面显示速度也就相应提高了。
- 管线化
    - 什么是管线化
        - 持久连接使得多数请求以管线化方式发送称为可能。从前发送请求后需等待并受到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。
        - ![image](https://upload-images.jianshu.io/upload_images/4432347-afd1dc2bb189ba9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    - 管线化的好处
        - 比如当请求一个包含10张图片的HTMLWeb页面，与挨个连接相比，用持久连接可以让请求更快，而管线化技术则比持久连接还要快。请求越多，时间差就越明显！



### 15.Http缓存原理
#### 15.1 http缓存有何控制
- Http的缓存主要利用header里的两个字段来控制：
    - Cache-control，ETag
- 缓存优点
    - 缓解服务器压力；
    - 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存在地理位置上也有可能比源服务器来得近，例如浏览器缓存。
- 缓存实现方法
    - 让代理服务器进行缓存；
    - 让客户端浏览器进行缓存。


#### 15.2 Cache-control介绍
- **Cache-control主要包含以及几个字段：**
    ```
    private:则只有客户端可以缓存
    public:客户端和代理服务器都可以缓存
    max-age:缓存的过期时间
    no-cache:需要使用对比缓存来验证缓存数据
    no-store:所有内存都不会进行缓存
    ```
- 实际上就是在这里面设置了一个缓存策略，由服务端第一次通过header下发给客户端，可以看到：
    - max-age即缓存过期的时间，则之后再次请求，如果没有超过缓存失效的时间则可以直接使用缓存。
    - no-cache:表示需要使用对比缓存来验证缓存数据，如果这个字段是打开的，则就算max-age缓存没有失效，则还是需要发起一次请求向服务端确认一下资源是否有更新，是否需要重新请求数据，至于怎么做对比缓存，就是下面要说的Etag的作用。如果服务端确认资源没有更新，则返回304，取本地缓存即可，如果有更新，则返回最新的资源。
    - no-store:这个字段打开，则不会进行缓存，也不会取缓存。
- Cache-Control
    - HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。
- 禁止进行缓存
    - no-store 指令规定不能对请求或响应的任何一部分进行缓存。
    ```html
    Cache-Control: no-store
    ```
- 强制确认缓存
    - no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效才将能使用该缓存对客户端的请求进行响应。
    ```html
    Cache-Control: no-cache
    ```
- 私有缓存和公共缓存
    - private指令规定了将资源作为私有缓存，只能被单独用户所使用，一般存储在用户浏览器中。
    ```html
    Cache-Control: private
    ```
    - public 指令规定了将资源作为公共缓存，可以被多个用户所使用，一般存储在代理服务器中。
    ```html
    Cache-Control: public
    ```
- 缓存过期机制
    - max-age指令出现在请求报文中，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。
    - max-age指令出现在响应报文中，表示缓存资源在缓存服务器中保存的时间。
    ```html
    Cache-Control: max-age=31536000
    ```
    - Expires首部字段也可以用于告知缓存服务器该资源什么时候会过期。
    ```html
    Expires: Wed, 04 Jul 2012 08:26:05 GMT
    ```
    - 在 HTTP/1.1 中，会优先处理 max-age 指令；
    - 在 HTTP/1.0 中，max-age 指令会被忽略掉。





#### 15.3 ETag介绍
- ETag:即用来进行对比缓存，Etag是服务端资源的一个标识码
    - 当客户端发送第一次请求时服务端会下发当前请求资源的标识码Etag，下次再请求时，客户端则会通过header里的If-None-Match将这个标识码Etag带上，服务端将客户端传来的Etag与最新的资源Etag做对比，如果一样，则表示资源没有更新，返回304。
    - 通过Cache-control和Etag的配合来实现Http的缓存机制。
- URL 不能唯一表示资源，例如 http://www.google.com/ 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。
    ```
    ETag: "82e22293907ce725faf67773957acd12"
    ```
    - 可以将缓存资源的ETag值放入If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新ETag值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。
    ```
    If-None-Match: "82e22293907ce725faf67773957acd12"
    ```
    - Last-Modified首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 Not Modified 响应。
    ```
    Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
    If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
    ```















