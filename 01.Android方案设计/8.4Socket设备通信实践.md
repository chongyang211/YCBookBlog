

### 06.稳定性实践说明
#### 6.1 性能设计
- 关于长链接心跳包优化【固定心跳】
    - 如果想节省资源，在有客户发送数据的时候可以省略 heart beat。目前的做法是发送数据的时候，更新发送ping【移除之前的ping消息，然后发送一条最新的延迟ping消息】
- 优化使用智能心跳策略【动态心跳】
    - 在尽量不影响用户收消息及时性的前提下，根据网络类型自适应的找出保活信令TCP连接的尽可能大的心跳间隔，从而达到减少App因心跳引起的空中信道资源消耗，减少心跳Server的负载，以及减少部分因心跳引起的耗电。
    - 第一种：自适应心跳。第二种：前后台策略。
- 自适应心跳的设计
    - 首先，如果心跳间隔越久，产生的负载和消耗也会越小。因此采用自适应心跳：当找到一个有效心跳间隔后，我们主动去加大这个间隔，然后测试是否能成功，如果不能，则使用比上一次成功间隔稍短的时间作为间隔；否则继续加大间隔，直到找到可用的有效间隔。
    - 如何判断一个心跳间隔有效呢？采用方案是使用固定短心跳直到满足三次连续短心跳成功，则认为这个间隔有效。
    - 探测过程大致为：60秒短心跳，连续发3次后开始探测，三次成功则改为90，依次类推120，150，180，210，240，270。
- 前后台策略的设计
    - 考虑到App在前后台对于长连接的需求是不同的。
    - 1.当App在前台活跃态时，采用了固定心跳机制；
    - 2.当前台熄屏态或者后台活跃态（进入后台10分钟内）时，先用几次最小心跳维持长连接，然后进入自适应心跳机制；
    - 3.当后台稳定态（超过10分钟），则采用自适应心跳计算出来的最大心跳作为固定值。



#### 6.2 稳定性设计
- 如何建立稳定长连接
    - 上面提到了多种长连接断开的原因，那我们应该如何进行优化，尽可能保证长连接不断开，或者及时断开了，也要尽快重连呢？
    - 第一种：长连接独立进程。将长连接逻辑单独提取到了一个独立的进程里。这个进程只做网络交互，消耗的内存等资源自然较少，从而减少了被系统回收的概率。
    - 第二种：心跳机制。对于心跳包很多人误以为只是用来定期告诉服务端我们的状态，实际并非如此。需要通过心跳机制来保证App的活跃度，防止发生 NAT 超时导致断开连接。
    - 第三种：断开重连。在线上运行时，长连接很有可能会由于网络切换之类的原因断开。这时，我们需要尽快发现长连接断开，并立即重连。



#### 6.3 灰度设计



#### 6.4 降级设计
- 长连接通道建设及容灾
    - 客户端与代理长连服务器建立长连接，代理服务器可全国多地部署，在建立长连时可以选择最近的服务器IP就近接入；
    - 长连接建立好后，客户端对要发送的二进制数据进行加密并传输；
    - 代理服务器收到后，可以通过内部专线或普通Http请求来访问业务服务器；
    - 如果长连接出现问题导致不可用，为保障客户端运行，需要立即降级成普通Http短连或者UDP通道。



#### 6.5 异常设计
- 如何处理读写异常逻辑？
    - 对读出错时候的处理，可能也存在一些争议。读出错后，我们只是关闭了 socket。socket 需要等到下一次写动作发生时，才会重新连接。
    - 实际应用中，如果这是一个问题，在读出错后可以直接开始重连。这种情况下，还需要一些额外的同步，避免重复创建 socket。



#### 6.6 安全性设计
- 长连接数据协议及加密
    - 长连接传递的是二进制数据，前后端可以自行协商每个字节要存放的内容即可。当然，也可以考虑采用一些通用协议：比如SMTP、ProtoBuf等序列化方案。
    - 在数据加密方面，可以结合非对称加密算法RSA和对称加密算法AES来对数据进行加密传输。



### 07.TCP/IP精髓设计
#### 7.1 协议版本如何升级
- 当我们对协议版本进行升级的时候，正确识别不同版本的协议对软件的兼容非常重要。那么，我们如何设计协议，才能够为将来的版本升级做准备呢？
    - 答案可以在 IP 协议找到。IP 协议的第一个字段叫 version，目前使用的是 4 或 6，分别表示 IPv4 和 IPv6。由于这个字段在协议的开头，接收端收到数据后，只要根据第一个字段的值就能够判断这个数据包是 IPv4 还是 IPv6。
    - 再强调一下，这个字段在两个版本的IP协议都位于第一个字段，为了做兼容处理，对应的这个字段必须位于同一位置。文本协议（如，JSON、HTML）的情况类似。



#### 7.2 如何发送不定长数据的数据包
- 举个例子，我们用微信发送一条消息。这条消息的长度是不确定的，并且每条消息都有它的边界。我们如何来处理这个边界呢？
    - 第一种：IP 的头部有个 header length 和 data length 两个字段。通过添加一个 len 域，我们就能够把数据根据应用逻辑分开。
    - 第二种：那就是在数据的末尾放置终止符。比方说，想 C 语言的字符串那样，我们在每个数据的末尾放一个 \0 作为终止符，用以标识一条消息的尾部。这个方法带来的问题是，用户的数据也可能存在 \0。此时，我们就需要对用户的数据进行转义。比方说，把用户数据的所有 \0 都变成 \0\0。读消息的过程总，如果遇到 \0\0，那它就代表 \0，如果只有一个 \0，那就是消息尾部。
- 两种方案优缺点分析
    - 第一种使用 len 字段的好处是，我们不需要对数据进行转义。读取数据的时候，只要根据 len 字段，一次性把数据都读进来就好，效率会更高一些。
    - 第二种终止符的方案虽然要求我们对数据进行扫描，但是如果我们可能从任意地方开始读取数据，就需要这个终止符来确定哪里才是消息的开头了。
    - 当然，这两个方法不是互斥的，可以一起使用。



#### 7.3 如何保证数据有序性
- 曾经遇到过的面试题。现在有一个任务队列，多个工作线程从中取出任务并执行，执行结果放到一个结果队列中。
    - 先要求，放入结果队列的时候，顺序顺序需要跟从工作队列取出时的一样（也就是说，先取出的任务，执行结果需要先放入结果队列）。
- 看看 TCP/IP 是怎么处理的。IP 在发送数据的时候，不同数据报到达对端的时间是不确定的，后面发送的数据有可能较先到达。TCP 为了解决这个问题，给所发送数据的每个字节都赋了一个序列号，通过这个序列号，TCP 就能够把数据按原顺序重新组装。
- 一样，我们也给每个任务赋一个值，根据进入工作队列的顺序依次递增。工作线程完成任务后，在将结果放入结果队列前，先检查要放入对象的写一个序列号是不是跟自己的任务相同，如果不同，这个结果就不能放进去。此时，最简单的做法是等待，知道下一个可以放入队列的结果是自己所执行的那一个。但是，这个线程就没办法继续处理任务了。
- 更好的方法是，我们维护多一个结果队列的缓冲，这个缓冲里面的数据按序列号从小到大排序。工作线程要将结果放入，有两种可能：
    - 刚刚完成的任务刚好是下一个，将这个结果放入队列。然后从缓冲的头部开始，将所有可以放入结果队列的数据都放进去。
    - 所完成的任务不能放入结果队列，这个时候就插入结果队列。然后，跟上一种情况一样，需要检查缓冲。
    - 如果测试表明，这个结果缓冲的数据不多，那么使用普通的链表就可以。如果数据比较多，可以使用一个最小堆。


#### 7.4 UDP传输数据可靠
- 模拟tcp



